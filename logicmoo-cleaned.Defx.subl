;; (f "Defx:ISOOpenCommandNLLogicPuzzleSolver&ControlProgramming-WorldAssumption-CommonLogic")
;; (a '(#$comment #$Defx:ISOOpenCommandNLLogicPuzzleSolver&ControlProgramming-WorldAssumption-CommonLogic "expressions with to describe a process that explores and manipulates data code vetted to handle unknowns ) Closed - world Assumption only when specified ( Code can use Law of Excluded Middle if needed ( but not required ) that are the input or output of inference engines ) English to ISO - CommonLogic Natural Language Generation ( From ISO - CommonLogic ) Provides Telnet and Web access to KB states") #$BaseKB)
(f "Defx:LogicMOO")
(a '(#$comment #$Defx:LogicMOO "supports incremental monotonic and non - monotonic updates that extend or non - monotonically change the assertion base") #$BaseKB)
(f "Defx:OntoMorph")
(a '(#$comment #$Defx:OntoMorph "translation system that supports writing of KB translators and importers , e.g. , to import ontologies written in other languages ( for example , F - logic like FLORA )") #$BaseKB)
(f "Defx:Resource-BoundedDepth-FirstOrIterativeDeepeningSearch")
(a '(#$comment #$Defx:Resource-BoundedDepth-FirstOrIterativeDeepeningSearch "provides an any - time inference scheme for situations where resources are limited") #$BaseKB)
(f "Defx:CommonLogic")
(a '(#$comment #$Defx:CommonLogic "framework for a family of logic languages , based on first - order logic , intended to facilitate the exchange and transmission of knowledge in computer - based systems") #$BaseKB)
(f "Defx:LogicmooMUD")
(a '(#$comment #$Defx:LogicmooMUD "MUD server with millions of rules and facts written in full higher order logic and beyond ( meta- and meta - meta- reasoning , reflection , modals , contexts , etc . )") #$BaseKB)
(f "Defx:SDETs")
(a '(#$comment #$Defx:SDETs "developers who design , develop and maintain automation systems - often expandable suites containing multiple automation programs - to be used by the development and test teams") #$BaseKB)
(f "Defx:PrologMUD")
(a '(#$comment #$Defx:PrologMUD "online system for multiplayer interactive fiction based on John McCarthy 's Elaboration Tolerance in Situation and Fluent Calculus") #$BaseKB)
(f "Defx:ACKNMTRANSINSULT")
(a '(#$comment #$Defx:ACKNMTRANSINSULT "I think that you have a lack of it ( sexy skin that is ! ) RECEIVE - YES") #$BaseKB)
(f "Defx:ApopheniaPatternMachines")
(a '(#$comment #$Defx:ApopheniaPatternMachines "who are motivated in some way towards seeing patterns whether they are there or not") #$BaseKB)
(f "Defx:Causality")
(a '(#$comment #$Defx:Causality "unique principle of the events in world") #$BaseKB)
(f "Defx:Commentary")
(a '(#$comment #$Defx:Commentary "emotions are in some way all through language formed ( not initiated by it , but the language give it a kind of form ) , but emotions have the power to understand without normal language : for example the silence , poesie etc") #$BaseKB)
(f "Defx:ConceptualDependencyTheory")
(a '(#$comment #$Defx:ConceptualDependencyTheory "describes language as these three levels of simplification A ) Pure Thought / Experience = Fully Complete and rich B ) Internal Dialog= meant to weakly describe the succession of thoughts C ) Outer dialog = leaves many gaps that internal dialog of listener must fill in -3- Nothing more to say") #$BaseKB)
(f "Defx:Conceptualization")
(a '(#$comment #$Defx:Conceptualization "act or doing something to an object in a direction") #$BaseKB)
(f "Defx:Jaynesian")
(a '(#$comment #$Defx:Jaynesian "newsletter of the Julian Jaynes Society") #$BaseKB)
(f "Defx:Logicmoo")
(a '(#$comment #$Defx:Logicmoo "attempt to create an programmable system in which we might define simplifications of language and consider them sometimes as the rules in which internal dialog is generated") #$BaseKB)
(f "Defx:Music")
(a '(#$comment #$Defx:Music "similar to poetry in that it uses ExternalRep ( C ) ( notes ) to gain direct access to the organism") #$BaseKB)
(f "Defx:Nomics")
(a '(#$comment #$Defx:Nomics "allows for disagreement and elaboration upon rules that define the runtime tasks ( programs ) that are running in the framework") #$BaseKB)
(f "Defx:AnalogicalPlanning")
(a '(#$comment #$Defx:AnalogicalPlanning "storing successful plans and adapting them to future problems episode indexing and retrieval : mechanisms for indexing and retrieval of cases serendipity detection and application : a mechanism for recognizing and exploiting accidental relationships among problems action mutation : a strategy for generating new possibilities when the system is stuck hierarchical planning : achieving a goal by breaking it down into subgoals The organism is most comfortable when the mind is speaking") #$BaseKB)
(f "Defx:BicameralMind")
(a '(#$comment #$Defx:BicameralMind "bold new theory of the origin of consciousness and a previous mentality") #$BaseKB)
(f "Defx:Choice")
(a '(#$comment #$Defx:Choice "represents ideas that cause the least mental anguish a limit on freedom within an otherwise unbridled range of thoughts") #$BaseKB)
(f "Defx:Consciousness")
(a '(#$comment #$Defx:Consciousness "inner voice ) has control to create new thoughts") #$BaseKB)
(f "Defx:ExistentialPhenomenons")
(a '(#$comment #$Defx:ExistentialPhenomenons "we do n't hear waves and decodify these waves in something else") #$BaseKB)
(f "Defx:HumanAffectScriptTheoryTheoryBeingTheory")
(a '(#$comment #$Defx:HumanAffectScriptTheoryTheoryBeingTheory "awareness regards human beings ' emotional responses to stimuli as falling into categories called ` ` affects '' and by what we cognitively do in terms of acting on that affect so that more was needed to produce a complete explanation") #$BaseKB)
(f "Defx:LogicmooLanguage")
(a '(#$comment #$Defx:LogicmooLanguage "recall of any experience as well as any symbolic tokens used to represent an experience") #$BaseKB)
(f "Defx:Narrative")
(a '(#$comment #$Defx:Narrative "creates a conundrum whereby each of us exists , for as long as we live , within an overall condition of nothingness ( nothingness ) that ultimately allows for free consciousness") #$BaseKB)
(f "Defx:NarrativeBlog")
(a '(#$comment #$Defx:NarrativeBlog "describes how and why we are doing and thinking what we are doing and thinking") #$BaseKB)
(f "Defx:Narratives")
(a '(#$comment #$Defx:Narratives "rewrite the past") #$BaseKB)
(f "Defx:Ontological")
(a '(#$comment #$Defx:Ontological "what is necessary , presupposed , and gives rise to the possibilities of enquiry") #$BaseKB)
(a '(#$comment #$Defx:Ontological "what is necessary , presupposed , and gives rise to the possibilities of enquiry") #$BaseKB)
(f "Defx:PatternMachines")
(a '(#$comment #$Defx:PatternMachines "biochemically bent towards seeing patterns whether they are there or not") #$BaseKB)
(f "Defx:StimmungFineTuning")
(a '(#$comment #$Defx:StimmungFineTuning "perception of nothingness through the fine tuning with the word that present itself as something that can become a nonsense ( the net can break up )") #$BaseKB)
(f "Defx:Stories")
(a '(#$comment #$Defx:Stories "Creates a story about the mental process of story creation it used") #$BaseKB)
;; (f "Defx:Unwind/Unwind")
;; (a '(#$comment #$Defx:Unwind/Unwind "rolling back things to start over") #$BaseKB)
;; (f "Defx:World/VulgarOntology")
;; (a '(#$comment #$Defx:World/VulgarOntology "cataloguing of the furniture of the universe") #$BaseKB)
(f "Defx:Goal")
(a '(#$comment #$Defx:Goal "when State if : precond statements are fluents or not Check for world state supports if : postcond predicates are present or missing and create initial support if : postcond statements are fluents or not Remove the magic wand object and decide if there is a plan that can reach a Goal Begin executing a plan a conjunction of facts ( and ( not ( spotless kitchen ) ) ( hungry puppy1 ) ) the planner expects some conjunction to be true ( and ( spotless kitchen ) ( not ( hungry puppy1 ) ) ) Performative tasks") #$BaseKB)
(f "Defx:Fluents")
(a '(#$comment #$Defx:Fluents "allays Computed imaginary performative task names") #$BaseKB)
(f "Defx:UpsideSelfCareDownside")
(a '(#$comment #$Defx:UpsideSelfCareDownside "guilt Create at least one performative that has similar upside and less or different downside Create at least one performative that has similar upside and no downsides Are there performatives that actually have no downside other than time resources") #$BaseKB)
(f "Defx:Answerable_t")
(a '(#$comment #$Defx:Answerable_t "Ctx Ctx ( asserted_t ( MT1 , Idea ) & true_t ( MT1 , genlMt , MT1 , MT2 ) = > true_t ( MT2 , Idea ) , Idea ) & ~possible_t ( Ctx , Idea ) & ~unknowable_t ( Ctx , Idea ) ) ) , ( ( ist ( MT1 , askable_t ( Ctx , Idea ) ) & genlMt ( MT1 , MT2 ) = > ist ( MT1 , ( true_t ( Ctx , Idea ) v unknowable_t ( Ctx , Idea ) v proven_false_t ( Ctx , Idea ) ) ) ) ) , Idea ) v fallacy_t ( Ctx , Idea ) v possible_t ( Ctx , Idea ) ) ) , ( ( ~possible_t ( Ctx , Idea ) = > proven_false_t ( Ctx , Idea ) v fallacy_t ( Ctx , Idea ) ) ) , ( ( ~proven_false_t ( Ctx , Idea ) = > fallacy_t ( Ctx , Idea ) v unknowable_t ( Ctx , Idea ) v true_t") #$BaseKB)
;; (f "Defx:Fallacy_tTrueLogicalAssertion''Ideas")
;; (a '(#$comment #$Defx:Fallacy_tTrueLogicalAssertion''Ideas "Ctx unknowable_t Ctx must Ideas Any % Any Idea that has been ` ` asserted '' into a blackboard context Idea that is ` ` true '' in a context must be ` ` assumed '' ( ( true_t ( Ctx , Idea ) = > assumed_t ( Ctx , Idea ) thought to be ` ` true '' and are yet ` ` proven false '' ( in context Ctx ) must be a ` ` fallacies '' ( at least in this context ) ( ( true_t ( Ctx , Idea ) & proven_false_t ( Ctx , Idea ) = > fallacy_t ( Ctx , Idea ) ) ) , % ` ` not be ` ` proven false '' and must be ` ` possible '' and at least ` ` not uknowable '' ( ( true_t ( Ctx , Idea ) = > ~proven_false_t ( Ctx , Idea ) & possible_t ( Ctx , Idea ) & ~unknowable_t ( Ctx , Idea ) ) ) , % ` ` proven false '' ideas are equivalent to being ` ` not true '' and ` ` not possible '' and ` ` knowable '' , Idea ) = > true_t ( Ctx , Idea ) v unknowable_t ( Ctx , Idea ) v proven_false_t ( Ctx , Idea ) ) ) , ( ( answerable_t ( Ctx , Idea ) < = > askable_t ( Ctx , Idea ) & ~unknowable_t ( Ctx , Idea ) ) ) , ( ( askable_t ( Ctx , Idea ) < = > ~fallacy_t ( Ctx , Idea ) ) ) , ( ( answerable_t ( Ctx , Idea ) = > true_t ( Ctx , Idea ) v proven_false_t ( Ctx , Idea ) ) ) , ( ( true_t ( Ctx , Idea ) v unknowable_t ( Ctx , Idea ) v proven_false_t ( Ctx , Idea ) ( Ctx , Idea ) = > proven_false_t ( Ctx , Idea ) & possible_t ( Ctx , Idea ) & ~asserted_t ( Ctx , Idea ) & ~proven_false_t ( Ctx , Idea ) ) ) , ( ( ~unknowable_t ( Ctx , Idea ) = > true_t ( Ctx , Idea ) v proven_false_t ( Ctx , Idea ) ) ) , ( ( ~asserted_t ( Ctx , Idea ) = > possible_t ( Ctx , Idea ) v proven_false_t ( Ctx , Idea ) v fallacy_t ( Ctx , Idea ) ) , Idea ) v unknowable_t ( Ctx , Idea ) v true_t ( Ctx , Idea ) ) ) , ( ( ~fallacy_t ( Ctx , Idea ) = > unknowable_t ( Ctx , Idea ) v proven_false_t ( Ctx , Idea ) v true_t ( Ctx , Idea ) ) ) * / %") #$BaseKB)
(f "Defx:AwakeKilledDeterminingFluentKilledDeterminingFluentKilledDeterminingFluent")
(a '(#$comment #$Defx:AwakeKilledDeterminingFluentKilledDeterminingFluentKilledDeterminingFluent "HumanTarget4 Awake Holding Standing Shoot PickUp Outside1 Side2 ( Door1 ) = Inside1 LookOutOnto ( Inside1 ) = Outside1 Floor ( Inside1 ) = 1 BuildingOf ( Inside1 ) = Building1 Side1 ( Street1 ) = Outside1 Side2 ( Street1 ) = Outside2 HoldsAt ( Alive ( Perp1 ) , 0 ) HoldsAt ( Awake ( Perp1 ) , 0 ) HoldsAt ( Perp1 , Gun1 ) , 0 ) Happens ( PickUp ( Perp1 , Bullet1 ) , 1 ) Happens ( PutInside ( Perp1 , Bullet1 , Gun1 ) , 2 ) Happens ( WalkStreet21 ( Perp1 , Street1 ) , 3 ) Happens ( Shoot ( Perp1 , Gun1 , PhysTarget1 ) , 4 ) Happens ( ShootDestroy ( Perp1 , Gun1 , PhysTarget1 ) , 4 ) Happens ( WalkStreet12 ( Perp1 , Street1 ) , 5 ) Given the above problem , the reasoner produces the following model : 0 Alive ( Perp1 ) At ( Bullet1 , Outside2 ( Perp1 , Gun1 , PhysTarget1 ) , 4 ) 5 -Inside ( Bullet1 , Gun1 ) -Intact ( PhysTarget1 ) -Loaded ( ( HumanTarget1 ) , 0 ) HoldsAt ( Sleep2 ( HumanTarget1 ) , 0 ) HoldsAt ( HumanTarget2 , object ) , 0 ) HoldsAt ( ( HumanTarget3 ) , 0 ) HoldsAt ) , 0 ) HoldsAt ( Injured ( HumanTarget4 ) , 0 ) HoldsAt ( Holding ( HumanTarget4 , object ) , 0 ) HoldsAt (") #$BaseKB)
(f "Defx:ComputationalMorality")
(a '(#$comment #$Defx:ComputationalMorality "process model of belief conflict and resolution for story generating") #$BaseKB)
(f "Defx:DecrementBurningPhysTarget1ArsonProblem")
(a '(#$comment #$Defx:DecrementBurningPhysTarget1ArsonProblem "PhysTarget1 Perp1 Perp1 Outside1 typical Arson problem , given one target that is DESTROYED Side2 ( Door1 ) = Inside1 LookOutOnto ( Inside1 ) = Outside1 Floor ( Inside1 ) = 1 BuildingOf ( Inside1 ) = Building1 Side1 ( Street1 ) = Outside1 Side2 ( Street1 ) = Outside2 HoldsAt ( Alive ( Perp1 ) , 0 ) HoldsAt ( Awake ( Perp1 ) , 0 , PhysTarget1 , Fire1 , 3 ) , 1 ) Happens ( WalkStreet12 ( Perp1 , Street1 ) , 2 ) Given the above problem , the reasoner produces the following model : 0 Alive ( Perp1 ) At ( Fire1 , Outside1 ) At ( Perp1 , Outside2 ) At ( PhysTarget1 , Outside1 ) Awake ( Perp1 ) DoorUnlocked ( Door1 ) Dressed ( Perp1 ) Intact ( PhysTarget1 ) NearPortal ( Fire1 , Door1 ) NearPortal ( Fire1 , Street1 ) NearPortal ( Perp1 , Street1 ) NearPortal ( , PhysTarget1 , Fire1 , 3 ) , 1 ) 2 + Burning ( PhysTarget1 , Fire1 , 3 ) Happens ( Damage ( Fire1 , PhysTarget1 ) , 2 ) Happens ( DecrementBurning ( PhysTarget1 ) , 2 ) Happens ( WalkStreet12 ( Perp1 , Street1 ) , 2 ) 3 -At ( Perp1 , Outside1 ) -Burning ( PhysTarget1 , Fire1 , 3 ) -Intact ( PhysTarget1 ) -NearPortal ( ) , 3 ) 4 -Burning ( PhysTarget1 , Fire1 , 2 ) + Burning ( PhysTarget1 , Fire1 , 1 ) Happens ( DecrementBurning ( PhysTarget1 ) , 4 ) 5 -Burning ( PhysTarget1 , Fire1 , 1 ) + Burning ( PhysTarget1 , Fire1 , 0 ) Happens ( Destroy ( Fire1 , PhysTarget1 ) , 5 ) 6 -Burning ( PhysTarget1 , Fire1 , 0 ) -Damaged ( PhysTarget1 ) + Destroyed ( PhysTarget1") #$BaseKB)
(f "Defx:EffectAxioms")
(a '(#$comment #$Defx:EffectAxioms "state that if an actor walks through one side of a door , the actor will be at the other side of the door : Axiom 22 Side2 ( door ) = location Initiates ( WalkThroughDoor12 ( actor , door ) , At ( actor , location ) , time )") #$BaseKB)
(f "Defx:GATE")
(a '(#$comment #$Defx:GATE "framework and graphical development environment for robust NLP tools and applications") #$BaseKB)
(f "Defx:HoldsAt")
(a '(#$comment #$Defx:HoldsAt "actor state that for an actor to walk through a side of a door , the actor must be awake and standing , the door must be open , and the actor must be at the side of the door that the actor walks through : Axiom 20 Happens , door ) , time") #$BaseKB)
(f "Defx:HoldsAtAxiom")
(a '(#$comment #$Defx:HoldsAtAxiom "states that if an actor is at a location , a bomb is at the location , the actor is nondeterministically killed , and the bomb explodes , then the bomb will kill the actor : Axiom 40") #$BaseKB)
(f "Defx:HoldsAtPreconditionAxiom")
(a '(#$comment #$Defx:HoldsAtPreconditionAxiom "states that for an actor to unlock a door , the actor must be awake , the door must not already be unlocked , and the actor must be near the door") #$BaseKB)
(a '(#$comment #$Defx:HoldsAtPreconditionAxiom "states that for an actor to open a door , the actor must be awake , the door must not already be open , the door must be unlocked , and the actor must be near the door") #$BaseKB)
(f "Defx:In-DepthCreating")
(a '(#$comment #$Defx:In-DepthCreating "Computer Model of Integrated Processing for Narrative Comprehension") #$BaseKB)
(f "Defx:IntrospectiveMultistrategyLearning")
(a '(#$comment #$Defx:IntrospectiveMultistrategyLearning "On the construction of learning strategies") #$BaseKB)
(f "Defx:KnowledgeInAction")
(a '(#$comment #$Defx:KnowledgeInAction "Logical Foundations for Specifying and Implementing Dynamical Systems") #$BaseKB)
(f "Defx:LetGoOf")
(a '(#$comment #$Defx:LetGoOf "Kill HumanTarget1 PickUp DoorIsOpen Injured Injured ( HumanTarget1 ) , 0 ) HoldsAt ( Holding ( HumanTarget1 , object ) , 0 ) HoldsAt ( ( Perp1 ) , 0 ) HoldsAt ( Holding ( Perp1 , object ) , 0 ) HoldsAt ( ( Door1 ) , 0 ) HoldsAt ( DoorUnlocked ( Door1 ) , 0 ) HoldsAt ( ThreatenedBy ( ( Perp1 , Gun1 ) , 0 ) 1 + Holding ( Perp1 , Gun1 ) Happens ( Hold ( Perp1 , Bullet1 ) , 1 ) Happens ( PickUp ( Perp1 , Bullet1 ) , 1 ) 2 + Holding ( Perp1 , Bullet1 , Perp1 ) , 4 ) Happens ( BecomeUnhappy ( HumanTarget1 ) , 4 ) Happens ( Threaten ( Perp1 , HumanTarget1 , Gun1 ) , 4 ) 5 -Calm ( HumanTarget1 ) + AngryAt ( HumanTarget1 , Perp1 ) + ThreatenedBy ( HumanTarget1 , Perp1 ) + Unhappy ( Bullet1 , HumanTarget1 ) , 9 ) Happens ( ShootKill ( Perp1 , Gun1 , HumanTarget1 ) , 9 ) Happens ( Shoot ( Perp1 , Gun1 , HumanTarget1 ) , 9 ) 10 -Alive ( HumanTarget1 ) -Inside ( Bullet1 , Gun1 ) -Loaded ( Gun1 , Bullet1 ) + Dead") #$BaseKB)
(f "Defx:Narratology")
(a '(#$comment #$Defx:Narratology "Form and Functioning of Narrative") #$BaseKB)
(f "Defx:NarrowCoverageSystems")
(a '(#$comment #$Defx:NarrowCoverageSystems "deal with stories about a particular domain or topic area such as management successions or terrorist incidents") #$BaseKB)
(f "Defx:PERP")
(a '(#$comment #$Defx:PERP "INDIVIDUAL ID UNIDENTIFIED PERSONS / A GROUP OF HEAVILY ARMED MEN / ARMED MEN / COMMANDO GROUP 11") #$BaseKB)
(a '(#$comment #$Defx:PERP "INDIVIDUAL ID UNIDENTIFIED PERSONS / A GROUP OF HEAVILY ARMED MEN / ARMED MEN / COMMANDO GROUP 11") #$BaseKB)
(f "Defx:PHYSTGT")
(a '(#$comment #$Defx:PHYSTGT "EFFECT OF INCIDENT * 6") #$BaseKB)
(f "Defx:Question-DrivenGenerating")
(a '(#$comment #$Defx:Question-DrivenGenerating "integrated theory of story generating , memory , and learning") #$BaseKB)
(f "Defx:SatisfiabilitySolvers")
(a '(#$comment #$Defx:SatisfiabilitySolvers "take as input a set of boolean variables and a propositional formula over those variables and produce as output zero or more models or satisfying truth assignments truth assignments for the variables such that the formula is true") #$BaseKB)
(f "Defx:ThoughtTreasureSystem")
(a '(#$comment #$Defx:ThoughtTreasureSystem "builds models of a story consisting of a sequence of time slices , where each time slice is a snapshot of ( a ) the physical world and ( b ) the mental world of each story character") #$BaseKB)
(f "Defx:Axiom")
(a '(#$comment #$Defx:Axiom "states that if a bomb explodes , the bomb destroys the bomb") #$BaseKB)
(f "Defx:CommonsenseKnowledgeBase")
(a '(#$comment #$Defx:CommonsenseKnowledgeBase "library of reusable event calculus representations of commonsense knowledge") #$BaseKB)
(f "Defx:CommonsenseReasoner")
(a '(#$comment #$Defx:CommonsenseReasoner "carries out inferences and fills in missing details in order to produce a model of the input text") #$BaseKB)
(f "Defx:CommonsenseReasoningProblem")
(a '(#$comment #$Defx:CommonsenseReasoningProblem "consists of an initial state , optional intermediate states , and a narrative of event occurrences") #$BaseKB)
(f "Defx:DirectHeader")
(a '(#$comment #$Defx:DirectHeader "activates a script when the story simply states that the script occurred") #$BaseKB)
(f "Defx:EffectAxiom")
(a '(#$comment #$Defx:EffectAxiom "states that if an object starts falling , then it will be falling : Axiom 2 Initiates ( StartFalling ( o ) , Falling ( o ) , t )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "states that if an object starts falling , then its height will be released from the commonsense law of inertia : Axiom 3 Releases ( StartFalling ( o ) , Height ( o , h ) , t )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "states that if the height of an object is h and the object hits the ground , then its height will no longer be released from the commonsense law of inertia and its height will be h : Axiom 6 HoldsAt ( Height ( o , h ) , t ) Initiates ( HitsGround ( o ) , Height ( o , h ) , t )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "states that if an object hits the ground , then the object will no longer be falling : Axiom 7 Terminates ( HitsGround ( o ) , Falling ( o ) , t )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "states that if an actor unlocks a door , the door will be unlocked : Axiom 16 Initiates ( DoorUnlock ( actor , door ) , DoorUnlocked ( door ) , time )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "states that if an actor opens a door , the door will be open : Axiom 19 Initiates ( DoorOpen ( actor , door ) , DoorIsOpen ( door ) , time )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "states that if a bomb is intact and an actor activates the bomb , the bomb will be activated : Axiom 30 HoldsAt ( Intact ( bomb ) , time ) Initiates ( BombActivate ( actor , bomb ) , BombActivated ( bomb ) , time )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "states that if a bomb is intact and an actor deactivates the bomb , the bomb will no longer be activated : Axiom 32 HoldsAt ( Intact ( bomb ) , time ) Terminates ( BombDeactivate ( actor , bomb ) , BombActivated ( bomb ) , time )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "states that if a bomb explodes , the bomb is no longer activated : Axiom 34 Terminates ( BombExplode ( bomb ) , BombActivated ( bomb ) , time )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "BombDecrementTimer states that if the timer value of the bomb is a timer value and the timer value of the bomb is decremented , the timer value of the bomb will be the timer value minus one ( bomb ) , BombTimerValue ( bomb , offset2 ) , time )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "states that if the timer value of the bomb is a timer value and the timer value of the bomb is decremented , the timer value of the bomb will no longer be the timer value : Axiom 37 HoldsAt ( BombTimerValue ( bomb , offset ) , time ) Terminates ( BombDecrementTimer ( bomb ) , BombTimerValue ( bomb , offset ) , time )") #$BaseKB)
(a '(#$comment #$Defx:EffectAxiom "states that if a bomb explodes , the bomb will no longer be activated : Axiom 38 Terminates ( BombExplode ( bomb ) , BombActivated ( bomb ) , time )") #$BaseKB)
(f "Defx:EventCalculus")
(a '(#$comment #$Defx:EventCalculus "includes sorts ( or types ) for fluents , events , time points , and domain objects") #$BaseKB)
(f "Defx:Fluent")
(a '(#$comment #$Defx:Fluent "time - varying proposition such as the fact that a particular object is in a particular room or that a particular character is hungry") #$BaseKB)
(a '(#$comment #$Defx:Fluent "at a location that has portal") #$BaseKB)
(f "Defx:InstrumentalHeader")
(a '(#$comment #$Defx:InstrumentalHeader "activates two scripts when a character uses one of the scripts as an instrument for the other script") #$BaseKB)
(f "Defx:PreconditionAxiom")
(a '(#$comment #$Defx:PreconditionAxiom "states that for an actor to activate a bomb , the actor must be holding the bomb") #$BaseKB)
(f "Defx:Reasoner")
(a '(#$comment #$Defx:Reasoner "uses the axioms of the commonsense knowledge base to make inferences and form detailed models") #$BaseKB)
(f "Defx:SatisfiabilitySolver")
(a '(#$comment #$Defx:SatisfiabilitySolver "sends zero or more models back to the manager") #$BaseKB)
(f "Defx:ScriptClassifier")
(a '(#$comment #$Defx:ScriptClassifier "classifies what script is active in the template") #$BaseKB)
(f "Defx:StateConstraint")
(a '(#$comment #$Defx:StateConstraint "says that an object is near a portal if and only if there is a location such that the object is at the location and one of the sides of the portal is the location") #$BaseKB)
(a '(#$comment #$Defx:StateConstraint "says that if a door is open , it is unlocked") #$BaseKB)
(f "Defx:TrajectoryAxiom")
(a '(#$comment #$Defx:TrajectoryAxiom "states that if an object starts falling at time t1 when its height is h1 , then its height at time t2 will be Max ( 0 , h1 t22 ) : Axiom 4 HoldsAt ( Height ( o , h1 ) , t1 ) h2 = Max ( 0 , h1 t22 ) Trajectory ( Falling ( o ) , t1 , Height ( o , h2 ) , t2 )") #$BaseKB)
(f "Defx:TriggerAxiom")
(a '(#$comment #$Defx:TriggerAxiom "Falling states that if an object is falling and its height is zero , then it will hit the ground ( o ) , t ) HoldsAt ( Height ( o , 0 ) , t") #$BaseKB)
(a '(#$comment #$Defx:TriggerAxiom "states that if a bomb is activated , the timer value of the bomb is a timer value , and the timer value is greater than zero , the timer value of the bomb will be decremented") #$BaseKB)
(a '(#$comment #$Defx:TriggerAxiom "BombTimerValue states that if the timer value of a bomb is zero , the bomb will explode ( bomb , 0 ) , time") #$BaseKB)
(f "Defx:ACEMELDLanguage")
(a '(#$comment #$Defx:ACEMELDLanguage "makes gives users the ability to use a controlled english to create the logic ( both query and assert non - monotonic defeasible logic the three types of knowledge interchangeable by using a unified representation that clearly defines logical equivalence between the three forms") #$BaseKB)
(f "Defx:Analogy")
(a '(#$comment #$Defx:Analogy "We learn new things at the fringe of what we already know , by relating them and comparing them to familiar things and then focusing on the differences") #$BaseKB)
(f "Defx:COMPLETESTRIPSPlanner")
(a '(#$comment #$Defx:COMPLETESTRIPSPlanner "can be applied directly to KB / Blackboard content , to plan and execute sequences of KB modification or external knowledge source invocation") #$BaseKB)
(f "Defx:CYC")
(a '(#$comment #$Defx:CYC "elaborate system to share data between several programs can be plugged into at one ( and process managed ) and make use of overlapping data ( related to AI and not )") #$BaseKB)
(f "Defx:English-To-LogicTranslation")
(a '(#$comment #$Defx:English-To-LogicTranslation "parser coupled to a semantically defined lexicon") #$BaseKB)
(f "Defx:Logicmoo")
(a '(#$comment #$Defx:Logicmoo "RobotOS A Knowledge Representation ( Object ) Language as an extension of Prolog GITMODULES https : //github.com / TeamSPoon / PrologMUD ~200 mb Package System interaction lm_library_bugger - Metapredicates that enable runtime debugging and logging of enforced determinisms lm_library_string - Propercase , CamelCase , Case - Insensitive Substring Matching , etc , etc lm_library_dcg_meta - Aggregation in DCG to make it easy to implement efficiency lm_library_misc - the rest of the helper predicates that do not fit above categories HPKB submodule deps required 90 % done pfc - Conveniently maintains your prolog database with a forward chainer / trigger system ( based on http : //www.csee.umbc.edu/~finin / prolog / pfc / man / pfc.pdf ) snark - With language based on Stanford 's SNARK language and Mark Stickel 's PTTP it creates an infrastructure that allows the programmer a harness for developing specialized reasoners based on KIF ( which has been named Game Description Language ! ) PrologMUD : 75 % done ( pfc / snark is mostly complete ) mud_server - Telnetable MUD is available that is coded in Prolog using all of the above") #$BaseKB)
(f "Defx:MELDMicrotheoryMechanism")
(a '(#$comment #$Defx:MELDMicrotheoryMechanism "Representing alternate belief structures , points of view , and contexts ; and characterizing which pieces of knowledge to include or exclude in deriving a particular answer Discourse and PEGs In normal English dialogue , an individual item is often represented using multiple terms and a number of forms of indirect reference , often strung out across a number of sentences , each using a different verbal representation of the item under discussion") #$BaseKB)
(f "Defx:Multi-UserDungeon")
(a '(#$comment #$Defx:Multi-UserDungeon "text adventure novel that several people play together in a simulated world") #$BaseKB)
(f "Defx:NARTs")
(a '(#$comment #$Defx:NARTs "terms formed by applying a PrologMUD function to its arguments") #$BaseKB)
(f "Defx:PEGs")
(a '(#$comment #$Defx:PEGs "flexible method of representing items under discussion even before you know their true identity , so you can reason about them") #$BaseKB)
(a '(#$comment #$Defx:PEGs "allow us to represent both the subway and the passengers so that we have something about which to reason") #$BaseKB)
(f "Defx:PrimitiveActs")
(a '(#$comment #$Defx:PrimitiveActs "predicates that specify active relationships in propositions") #$BaseKB)
(f "Defx:PrimitiveStates")
(a '(#$comment #$Defx:PrimitiveStates "predicates that specify nonactive states of affairs") #$BaseKB)
(f "Defx:PrologMUDTerm")
(a '(#$comment #$Defx:PrologMUDTerm "argument to PrologMUD predicate or function ) which is neither a variable nor an atomic ( one word ) atom") #$BaseKB)
(f "Defx:REASONINITIATIONDISABLEENABLERESULTCausationCausationCausationCausationCausation")
(a '(#$comment #$Defx:REASONINITIATIONDISABLEENABLERESULTCausationCausationCausationCausationCausation "state state state action RESULTS IN state change ENABLES action DISABLES action or act INITIATES mental state") #$BaseKB)
(f "Defx:SceneCyclonePersistence")
(a '(#$comment #$Defx:SceneCyclonePersistence "Basically Using the pfc / snark harnesses we implement a powerful clone of CYC inference engine in Prolog ( instead of SubL ) while still conforming to all the CycL specs including TMS / WFF checking , canonicalizers , Proof Outputs and Subsumptive heuristic modules") #$BaseKB)
;; (f "Defx:ScriptCause/EffectLogicTheoryLogic")
;; (a '(#$comment #$Defx:ScriptCause/EffectLogicTheoryLogic "first move Y to Z next move A to B '' or ` ` Joe waves at Stan , Stan says ' hi ! ' '' One of the few systems that keeps ( 2 ) natural") #$BaseKB)
(f "Defx:ActionJump")
(a '(#$comment #$Defx:ActionJump "represent Represents the class of all persons [ aka cyc : Person foaf : Person ] iPerson666 = the [ object ] person 666 The system generated an tPerson iJoe = the [ object ] joe Probably we put this into a game file value that is represented as an integer tActJump = type instances of jumping like : actJump ( iJoe ) iMotherFn") #$BaseKB)
(f "Defx:ActionMutation")
(a '(#$comment #$Defx:ActionMutation "strategy for generating new possibilities when the system is stuck") #$BaseKB)
(a '(#$comment #$Defx:ActionMutation "strategy for generating new possibilities when the system is stuck") #$BaseKB)
(f "Defx:AnalogicalPlanning")
(a '(#$comment #$Defx:AnalogicalPlanning "storing successful plans and adapting them to future problems") #$BaseKB)
(a '(#$comment #$Defx:AnalogicalPlanning "storing successful plans and adapting them to future problems") #$BaseKB)
(f "Defx:ConceptualOntologies")
(a '(#$comment #$Defx:ConceptualOntologies "structured real - world information into computer - understandable data") #$BaseKB)
(f "Defx:ConversationalPlan")
(a '(#$comment #$Defx:ConversationalPlan "helps one to understand the intent of a particular dialogue contribution ; how it fits in to the overall knowledge augmentation task") #$BaseKB)
(f "Defx:DialoguePlan")
(a '(#$comment #$Defx:DialoguePlan "predicts what an SME is likely to say next , and is used to drastically trim away obvious pieces of the system s outputs to the SME") #$BaseKB)
(f "Defx:HelpSystem")
(a '(#$comment #$Defx:HelpSystem "shows interface to accessing commands and data types") #$BaseKB)
(f "Defx:HierarchicalPlanning")
(a '(#$comment #$Defx:HierarchicalPlanning "achieving a goal by breaking it down into subgoals") #$BaseKB)
(f "Defx:InteractionPlan")
(a '(#$comment #$Defx:InteractionPlan "relates dialogue plans within a pragmatic frame ( which captures the current general state of the task oriented dialogue") #$BaseKB)
(f "Defx:ObjectTypes")
(a '(#$comment #$Defx:ObjectTypes "things that are spatially located someplace in some container however they may be fully intangible such as a magic spell") #$BaseKB)
(f "Defx:DefeasibleReasoning")
(a '(#$comment #$Defx:DefeasibleReasoning "particular kind of non - demonstrative reasoning , where the reasoning does not produce a full , complete , or final demonstration of a claim , i.e. , where fallibility and corrigibility of a conclusion are acknowledged") #$BaseKB)
(f "Defx:DialetheismCYC")
(a '(#$comment #$Defx:DialetheismCYC "uses Paraconsistency by forcing inference into ` ` Problem solving contexts '' PSCs PSCs explore MTs expecting them to be individually consistent but sometimes when combined create the need for one of the 6 styles of inference listed above") #$BaseKB)
(f "Defx:DynamicIntuitionisticLogicEpistemicLogic")
(a '(#$comment #$Defx:DynamicIntuitionisticLogicEpistemicLogic "creates generates a program based on a mathematical proof") #$BaseKB)
(f "Defx:ElaborationTolerance")
(a '(#$comment #$Defx:ElaborationTolerance "ability to accept changes to a person s or a computer program s representation of facts about a subject without having to start all over") #$BaseKB)
(f "Defx:Inductive")
(a '(#$comment #$Defx:Inductive "differences about the conditional that each kind of reasoning uses , and on what premise ( or on what authority ) the conditional is adopted : Deductive ( from meaning postulate , axiom , or contingent assertion ) : if p then q ( i.e. , q or not - p ) Defeasible ( from authority ) : if p then ( defeasibly ) q Probabilistic ( from combinatorics and indifference ) : if p then ( probably ) q Statistical ( from data and presumption ) : the frequency of qs among ps is high ( or inference from a model fit to data ) ; hence , ( in the right context ) if p then") #$BaseKB)
(f "Defx:RelevanceLogic")
(a '(#$comment #$Defx:RelevanceLogic "class of formulas valid over a class of Kripke ( relational ) frames") #$BaseKB)
(f "Defx:AdaptiveLogicProgram")
(a '(#$comment #$Defx:AdaptiveLogicProgram "considers systems in which the rules of inference themselves can change as we go along") #$BaseKB)
(f "Defx:DefeasibleReasoning")
(a '(#$comment #$Defx:DefeasibleReasoning "kind of reasoning that is rationally compelling though not deductively valid") #$BaseKB)
(f "Defx:Dirt")
(a '(#$comment #$Defx:Dirt "any natural material in an unwanted place , or weed as any plant growing where the speaker feels it should not be") #$BaseKB)
(f "Defx:ExpressivePower")
(a '(#$comment #$Defx:ExpressivePower "breadth of ideas that can be represented and communicated in that language") #$BaseKB)
(f "Defx:ParaconsistentLogic")
(a '(#$comment #$Defx:ParaconsistentLogic "way to reason about inconsistent information without lapsing into absurdity") #$BaseKB)
(f "Defx:ParaconsistentLogics")
(a '(#$comment #$Defx:ParaconsistentLogics "tools for damage control") #$BaseKB)
(a '(#$comment #$Defx:ParaconsistentLogics "underwrite the claim that some contradictions really are true") #$BaseKB)
(f "Defx:StrongParaconsistency")
(a '(#$comment #$Defx:StrongParaconsistency "maintains that all contradictions are false even though some contradictions also are true") #$BaseKB)
(f "Defx:WeakParaconsistency")
(a '(#$comment #$Defx:WeakParaconsistency "accepts that any apparent contradictions are always due to human element ; ( Maybe the human was going to finish the details later that would resolve the contradictions") #$BaseKB)
;; (f "Defx:HASCLIFHASTelnetHASCLIFTelnetLiveTelnetConsoleEditingPrologFilesConsoleFiles-BOUNTY$1000Console-BOUNTY$1000Files-BOUNTY$1000")
;; (a '(#$comment #$Defx:HASCLIFHASTelnetHASCLIFTelnetLiveTelnetConsoleEditingPrologFilesConsoleFiles-BOUNTY$1000Console-BOUNTY$1000Files-BOUNTY$1000 "reuse RESEARCH For multiple people trying / editing the server ( Only one of these may be selected ) Eclipse IDE Shared PDT server HAS - BOUNTY $ 300 ( Lang : Prolog ) 6 hours ( Multiple instances of PDT use the same server ) Shared MUD Project IF HTML DISPLAY IS DONE ) PDDL Files ( reuse VSC - PDDL plugin code VSC - PDDL plugin code") #$BaseKB)
(f "Defx:LogicMOORules")
(a '(#$comment #$Defx:LogicMOORules "perform pattern - matching directly over the object base") #$BaseKB)
(f "Defx:MetaruleProtocol")
(a '(#$comment #$Defx:MetaruleProtocol "Complete control over the forward chaining cycle is available through the Metarule Protocol ( MRP )") #$BaseKB)
(f "Defx:ReactivePrograms")
(a '(#$comment #$Defx:ReactivePrograms "designed to react to input streams that in theory may be infinite , and thus show ideally nonterminating behavior") #$BaseKB)
(f "Defx:ScalarIntervalsSituation")
(a '(#$comment #$Defx:ScalarIntervalsSituation "words but not strings") #$BaseKB)
(f "Defx:SitCalc")
(a '(#$comment #$Defx:SitCalc "formal method to encode experiences well enough to relive them upon rememberance") #$BaseKB)
(f "Defx:BackwardForwardChainingRulesChainingRules")
(a '(#$comment #$Defx:BackwardForwardChainingRulesChainingRules "use this pattern - matching to perform actions") #$BaseKB)
(f "Defx:ClassOfElephants")
(a '(#$comment #$Defx:ClassOfElephants "mental object in the sense that it can be communicated") #$BaseKB)
(f "Defx:Terminal")
(a '(#$comment #$Defx:Terminal "current state is a terminal state") #$BaseKB)
(f "Defx:CLIFTelnetConsoleFiles")
(a '(#$comment #$Defx:CLIFTelnetConsoleFiles "RESEARCH IF HTML DISPLAY IS DONE ) PDDL Files") #$BaseKB)
(f "Defx:LogicMOORules")
(a '(#$comment #$Defx:LogicMOORules "perform pattern - matching directly over the object base") #$BaseKB)
(f "Defx:MetaruleProtocol")
(a '(#$comment #$Defx:MetaruleProtocol "Complete control over the forward chaining cycle is available through the Metarule Protocol ( MRP )") #$BaseKB)
(f "Defx:ReactivePrograms")
(a '(#$comment #$Defx:ReactivePrograms "designed to react to input streams that in theory may be infinite , and thus show ideally nonterminating behavior") #$BaseKB)
(f "Defx:ScalarIntervalsSituation")
(a '(#$comment #$Defx:ScalarIntervalsSituation "words but not strings") #$BaseKB)
(f "Defx:BackwardForwardChainingRulesChainingRules")
(a '(#$comment #$Defx:BackwardForwardChainingRulesChainingRules "use this pattern - matching to perform actions") #$BaseKB)
(f "Defx:ClassOfElephants")
(a '(#$comment #$Defx:ClassOfElephants "mental object in the sense that it can be communicated") #$BaseKB)
(f "Defx:Terminal")
(a '(#$comment #$Defx:Terminal "current state is a terminal state") #$BaseKB)
(f "Defx:HornClause")
(a '(#$comment #$Defx:HornClause "clause with at most one positive literal , called the head of the clause , and any number of negative literals , forming the body of the clause") #$BaseKB)
(f "Defx:HornFormula")
(a '(#$comment #$Defx:HornFormula "propositional formula formed by conjunction of Horn clauses") #$BaseKB)
(f "Defx:RamseyTest")
(a '(#$comment #$Defx:RamseyTest "holds if and only if the addition of A to the current body of knowledge has B as a consequence") #$BaseKB)
(f "Defx:UnitPropagation")
(a '(#$comment #$Defx:UnitPropagation "applied repeatedly as new unit clauses are generated , is a complete satisfiability algorithm for sets of propositional Horn clauses ; it also generates a minimal model for the set if satisfiable") #$BaseKB)
(f "Defx:Auto-Epistemological")
(a '(#$comment #$Defx:Auto-Epistemological "rules governing the system 's understanding of proving things") #$BaseKB)
(f "Defx:MinimalModelOfTheHornFormula")
(a '(#$comment #$Defx:MinimalModelOfTheHornFormula "assignment having a minimal set of variables assigned to true , where comparison is made using set containment") #$BaseKB)
(f "Defx:Renamable-HornFormulae")
(a '(#$comment #$Defx:Renamable-HornFormulae "set of formulae that can be placed in Horn form by replacing some variables with their respective negation") #$BaseKB)
(f "Defx:Resolution")
(a '(#$comment #$Defx:Resolution "complete refutation procedure while unit propagation is not ; in other words , even if a set of clause is contradictory") #$BaseKB)
(f "Defx:UnitPropagation")
(a '(#$comment #$Defx:UnitPropagation "correct inference rule , in that it never produces a new clause that was not entailed by the old ones") #$BaseKB)
(a '(#$comment #$Defx:UnitPropagation "if the formula contains a clause composed of a single literal ( a unit clause ) , then all clauses containing ( except the unit clause itself ) are removed , and all clauses containing have this literal removed") #$BaseKB)
;; (f "Defx:A.2.3.11PhraseCLIFText")
;; (a '(#$comment #$Defx:A.2.3.11PhraseCLIFText "sequence of phrases , each of which is either a sentence , a module , an importation or a plain text with an attached comment") #$BaseKB)
(f "Defx:ApplicationConformanceApplication")
(a '(#$comment #$Defx:ApplicationConformanceApplication "any piece of computational machinery ( software or hardware , or a network ) which performs any operations on CL text ( even very trivial operations like storing it for later re - transmission") #$BaseKB)
;; (f "Defx:Atomic.classBoolean.class````")
;; (a '(#$comment #$Defx:Atomic.classBoolean.class```` "boolean | and | or | implies | iff | not") #$BaseKB)
(f "Defx:CGAbstractSyntax")
(a '(#$comment #$Defx:CGAbstractSyntax "notation - independent specification of the expressions and components of the conceptual graph core , which is the minimal CG subset capable of expressing the full CL semantics") #$BaseKB)
(f "Defx:CLIFCommentsSyntax")
(a '(#$comment #$Defx:CLIFCommentsSyntax "treats a commented expression as identical in meaning to the expression without the comment , so the comment can be considered to be attached to the uncommented expression") #$BaseKB)
(f "Defx:CommonLogic")
(a '(#$comment #$Defx:CommonLogic "family of languages rather than a single language") #$BaseKB)
(a '(#$comment #$Defx:CommonLogic "intended to be used for information interchange over a network , as far as possible without requiring any translation to be done ; and when it shall be done , Common Logic provides a single common semantic framework , rather than a syntactically defined interlingua") #$BaseKB)
(f "Defx:CommonSortedLogicLogicSystemLogicExpression")
(a '(#$comment #$Defx:CommonSortedLogicLogicSystemLogicExpression "individual , consisting of either a name or , recursively , a function term applied to a sequence of arguments , which are themselves terms") #$BaseKB)
(f "Defx:ConceptualGraphInterchangeFormat")
(a '(#$comment #$Defx:ConceptualGraphInterchangeFormat "fully conformant dialect of Common Logic ( CL ) that serves as a serialized representation for conceptual graphs") #$BaseKB)
(f "Defx:InformationTechnologyCommonLogic")
(a '(#$comment #$Defx:InformationTechnologyCommonLogic "framework for a family of logic - based languages 1 Scope This International Standard specifies a family of logic languages designed for use in the representation and interchange of information and data among disparate computer systems") #$BaseKB)
(f "Defx:Innernamequote")
(a '(#$comment #$Defx:Innernamequote "used to indicate the presence of a double - quote character inside an enclosed name") #$BaseKB)
(f "Defx:IntroductionCommonLogic")
(a '(#$comment #$Defx:IntroductionCommonLogic "logic framework intended for information exchange and transmission") #$BaseKB)
(f "Defx:Logical-Form-OfDescription")
(a '(#$comment #$Defx:Logical-Form-OfDescription "optional attribute on all XCL sentence elements , whose value is a URI reference indicating a syntactic category in some external language specification") #$BaseKB)
(f "Defx:SequenceMarkers")
(a '(#$comment #$Defx:SequenceMarkers "used to indicate a subsequence of a term sequence") #$BaseKB)
(f "Defx:TypeTheory")
(a '(#$comment #$Defx:TypeTheory "particular class of such logics in which relation symbols are separated into orders , with relations of order n applying only to those of lower orders") #$BaseKB)
(f "Defx:UDI")
(a '(#$comment #$Defx:UDI "universe or domain of discourse containing all the individual things the interpretation is ' about ' and over which the quantifiers range") #$BaseKB)
(f "Defx:URI")
(a '(#$comment #$Defx:URI "universe of reference , with a distinguished nonempty subset UDI , the universe of discourse , and four mappings : relI from URI") #$BaseKB)
(f "Defx:URIFunIRelI")
(a '(#$comment #$Defx:URIFunIRelI "mapping from URI to functions from UDI * to UDI I an interpretation mapping from URI to subsets of UDI * seqI a mapping from sequence markers in V to UDI * V a vocabulary , which is non - empty set of individuals that an interpretation I is about and over which the quantifiers are understood to range URI the universe of reference") #$BaseKB)
(f "Defx:XCLModule")
(a '(#$comment #$Defx:XCLModule "Indicates that the enclosed content is considered to be an XCL module ( aka ontology fragment of XCL markup which has special attributes and satisfies certain extra constraints") #$BaseKB)
(f "Defx:AtomicSentence")
(a '(#$comment #$Defx:AtomicSentence "CG consisting of either a conceptual relation or a concept") #$BaseKB)
(f "Defx:AxiomAxiom")
(a '(#$comment #$Defx:AxiomAxiom "any sentence which is assumed to be true , from which others are derived , or by which they are entailed sentence which is never posed as a goal to be proved , but only used to prove other sentences") #$BaseKB)
(f "Defx:BlankConceptualGraph")
(a '(#$comment #$Defx:BlankConceptualGraph "set of concepts , R is a set of conceptual relations , and A is the set of arcs that shall consist of all and only those arcs that occur in the arc sequence of some conceptual relation in R. If C and R are both empty , then A is also empty , and g") #$BaseKB)
(f "Defx:BooleanDefinition")
(a '(#$comment #$Defx:BooleanDefinition "string b that shall contain a context bc , which shall not directly contain a reference or a defining label") #$BaseKB)
(f "Defx:ClassicalDialect")
(a '(#$comment #$Defx:ClassicalDialect "segregated dialect in which all operators and predicates are non - discourse names and all non - discourse names are operators or predicates") #$BaseKB)
(f "Defx:Comment")
(a '(#$comment #$Defx:Comment "piece of data") #$BaseKB)
(f "Defx:CommunicationNetwork")
(a '(#$comment #$Defx:CommunicationNetwork "system of agents which can store , publish or process Common Logic text , and can transmit Common Logic text to one another by means of information transfer protocols associated with the network") #$BaseKB)
(f "Defx:CompactSub-Dialect")
(a '(#$comment #$Defx:CompactSub-Dialect "dialect that recognizes all categories except sequence markers") #$BaseKB)
(f "Defx:ConceptNodes")
(a '(#$comment #$Defx:ConceptNodes "contain the input and output values of the actors") #$BaseKB)
(f "Defx:ConceptualGraph")
(a '(#$comment #$Defx:ConceptualGraph "representation for logic as a bipartite graph with two kinds of nodes , called concepts and conceptual relations") #$BaseKB)
(a '(#$comment #$Defx:ConceptualGraph "consists an unordered set of concepts , conceptual relations , negations , and comments") #$BaseKB)
(a '(#$comment #$Defx:ConceptualGraph "string cg consisting of an unordered sequence of substrings that represent concepts , conceptual relations , booleans , and comments") #$BaseKB)
(f "Defx:ConceptualGraphTheory")
(a '(#$comment #$Defx:ConceptualGraphTheory "form of first - order logic which represents existential quantification and conjunction via the assertion of logical constructs called concepts and relations , which are arranged in an abstract or visually displayed graph") #$BaseKB)
(f "Defx:ConformanceSet")
(a '(#$comment #$Defx:ConformanceSet "defined relative to a collection of dialects") #$BaseKB)
(a '(#$comment #$Defx:ConformanceSet "defined relative to a collection of dialects") #$BaseKB)
(f "Defx:Conformant")
(a '(#$comment #$Defx:Conformant "transmits all expressions of all dialects in the conformance set without distortion from any node in the network to any other node , and provides for network identifiers which satisfy the semantic conditions E17 , E20 and as described in clause 6.2") #$BaseKB)
(f "Defx:Context")
(a '(#$comment #$Defx:Context "Any concept that contains a nested CG") #$BaseKB)
(f "Defx:CoreferenceLabel")
(a '(#$comment #$Defx:CoreferenceLabel "CG name with the prefix ` ` * ''") #$BaseKB)
(f "Defx:Dialect")
(a '(#$comment #$Defx:Dialect "specification of a language") #$BaseKB)
(f "Defx:DialectErrorCondition")
(a '(#$comment #$Defx:DialectErrorCondition "Any error generated during the translation should be reported as") #$BaseKB)
(f "Defx:DialectModel-TheoreticSemanticsInterpretations")
(a '(#$comment #$Defx:DialectModel-TheoreticSemanticsInterpretations "assigns one of the two truth - values true or false to every sentence , phrase ( except comment ) or text in that dialect") #$BaseKB)
(f "Defx:DiscourseNames")
(a '(#$comment #$Defx:DiscourseNames "Names which are not non - discourse names") #$BaseKB)
(f "Defx:Double-QuoteSingle-QuoteEqualitySign")
(a '(#$comment #$Defx:Double-QuoteSingle-QuoteEqualitySign "single lexical item when it is the first character of an item") #$BaseKB)
(f "Defx:EnclosedName")
(a '(#$comment #$Defx:EnclosedName "simply a name which may contain characters which would break the lexicalization , such as Mrs Norah Jones or Girl ( interrupted ) ; like any other name , it may denote anything") #$BaseKB)
(f "Defx:ExistentiallyQuantifiedSentence")
(a '(#$comment #$Defx:ExistentiallyQuantifiedSentence "quantified sentence whose quantifier is existential") #$BaseKB)
(f "Defx:External")
(a '(#$comment #$Defx:External "semantic extension which fixes the meanings of certain special names ( such as datatypes ) , or specifies relationships between Common Logic and other naming conventions , such as network identification conventions") #$BaseKB)
(f "Defx:Importation")
(a '(#$comment #$Defx:Importation "amounts to a virtual copying of some Common Logic content from one place to another") #$BaseKB)
(f "Defx:Innerstringquote")
(a '(#$comment #$Defx:Innerstringquote "used to indicate the presence of a single - quote character inside a quoted string") #$BaseKB)
(f "Defx:LogicalSyntaxOfCLIF")
(a '(#$comment #$Defx:LogicalSyntaxOfCLIF "written assuming that lexical items have been isolated from one another by a lexical analyser") #$BaseKB)
(f "Defx:ModuleNameExclusionSet")
(a '(#$comment #$Defx:ModuleNameExclusionSet "indicates any names in the text which are explicitly excluded from this local universe") #$BaseKB)
(f "Defx:Name")
(a '(#$comment #$Defx:Name "any lexical token which is understood to denote") #$BaseKB)
(f "Defx:NamedTextValue")
(a '(#$comment #$Defx:NamedTextValue "semantic entity corresponding to a named text") #$BaseKB)
(f "Defx:Negation")
(a '(#$comment #$Defx:Negation "pair consisting of a concept and a conceptual relation that are never separated in CGIF") #$BaseKB)
(f "Defx:NegationsBiconditionals")
(a '(#$comment #$Defx:NegationsBiconditionals "have have exactly two components exactly one component") #$BaseKB)
(f "Defx:Network")
(a '(#$comment #$Defx:Network "presumed to support communication and publication of Common Logic content in some subset of dialects") #$BaseKB)
(f "Defx:Non-Segregated")
(a '(#$comment #$Defx:Non-Segregated "dialect which is not segregated") #$BaseKB)
(f "Defx:Non-SegregatedText")
(a '(#$comment #$Defx:Non-SegregatedText "all quantifiers are restricted or guarded by the segregated domain name , and all non - discourse names are asserted to be outside that domain") #$BaseKB)
(f "Defx:Nonascii")
(a '(#$comment #$Defx:Nonascii "set of characters or character sequences which indicate a Unicode character outside the ASCII range") #$BaseKB)
(f "Defx:Parsing")
(a '(#$comment #$Defx:Parsing "assignment of each part of a legal inscription into its corresponding CL abstract syntax category in clause 6.1.1 , and the parsed inscription is an expression") #$BaseKB)
(f "Defx:QuantifiedSentenceQuantifiedSentence")
(a '(#$comment #$Defx:QuantifiedSentenceQuantifiedSentence "exists quantified sentence ( exists ( N1 ) T [ ( exists ( ) ( and ( T1 N1 ) B ) ] A quantified sentence ( forall G ( ) B ) The quantified sentence T [ ( forall ( ) ( if ( G X1 Xn ) B ) ] where X1 Xn are all the names which occur free in B G ( ) B ) The quantified sentence T [ ( exists ( ) ( and ( G X1 Xn ) B ) ] where X1 Xn are all the names which occur free in B A module ( cl : module N ( cl : excludes N1 text T in which every name or sequence marker X in the boundlist of a quantifier is replaced with ( X N ) The forms on the left side of Table A.2 can be considered to be syntactic sugar for their translations on the right") #$BaseKB)
(f "Defx:QuantifierBindingSequenceBindingOfTheQuantifiedSentence")
(a '(#$comment #$Defx:QuantifierBindingSequenceBindingOfTheQuantifiedSentence "finite , nonrepeating sequence of names and sequence markers") #$BaseKB)
(f "Defx:QuotedString")
(a '(#$comment #$Defx:QuotedString "expression with a fixed semantic meaning : it denotes a text string similarly related to the string inside the quotes") #$BaseKB)
(f "Defx:RigidIdentifierConvention")
(a '(#$comment #$Defx:RigidIdentifierConvention "external semantic condition which all interpretations of texts published on the communication network are required to satisfy") #$BaseKB)
(f "Defx:Segregated")
(a '(#$comment #$Defx:Segregated "dialect with non - discourse names") #$BaseKB)
(f "Defx:SegregatedDialect")
(a '(#$comment #$Defx:SegregatedDialect "shall provide sufficient syntactic constraints to guarantee that in any syntactically legal text of the dialect : Every name shall be classified as either discourse or as non - discourse") #$BaseKB)
(a '(#$comment #$Defx:SegregatedDialect "syntactically segregated dialect which requires names in one or more categories to not denote entities in the set over which its quantifiers range") #$BaseKB)
(f "Defx:SemanticExtension")
(a '(#$comment #$Defx:SemanticExtension "dialect which satisfies the first condition , but does not satisfy the second condition") #$BaseKB)
(f "Defx:SemanticSub-Dialect")
(a '(#$comment #$Defx:SemanticSub-Dialect "syntactic sub - dialect ( see clause 7.1.1 above ) and meets the semantic conditions ; that is , it recognizes only some parts of the full Common Logic and its interpretations are equivalent to the restrictions of a Common Logic interpretation to those parts") #$BaseKB)
(f "Defx:SemanticsOfCommonLogic")
(a '(#$comment #$Defx:SemanticsOfCommonLogic "defined in terms of a satisfaction relation between Common Logic text and mathematical structures called interpretations") #$BaseKB)
(f "Defx:SequenceLabel")
(a '(#$comment #$Defx:SequenceLabel "sequence marker with the prefix ` ` * ''") #$BaseKB)
(f "Defx:SyntacticallyCompactDialect")
(a '(#$comment #$Defx:SyntacticallyCompactDialect "dialect that does not include sequence markers , but is otherwise fully conformant") #$BaseKB)
(f "Defx:SyntacticallyPartialCommonLogicDialect")
(a '(#$comment #$Defx:SyntacticallyPartialCommonLogicDialect "dialect which provides only some types of the Common Logic expressions") #$BaseKB)
(f "Defx:SystematicAbbreviations")
(a '(#$comment #$Defx:SystematicAbbreviations "kinds of quantifier ) which are equivalent in meaning to a construction using just this syntax , interpreted according to the Common Logic semantics") #$BaseKB)
(f "Defx:TermSequence")
(a '(#$comment #$Defx:TermSequence "finite sequence of terms or sequence markers") #$BaseKB)
(f "Defx:Text")
(a '(#$comment #$Defx:Text "set , list , or bag of phrases") #$BaseKB)
(f "Defx:TextDefinition")
(a '(#$comment #$Defx:TextDefinition "context c that is not contained directly or indirectly in any context") #$BaseKB)
(f "Defx:Translation")
(a '(#$comment #$Defx:Translation "mapping from expressions in a text in some dialect A , the source dialect , to expressions in a text in some dialect B , the target dialect , such that for every interpretation I of the vocabulary of the text in A there is an interpretation J of the vocabulary of the text in B , and for every interpretation J of the vocabulary of the text in B there is an interpretation I of the vocabulary of the text in A , with I ( E ) = J ( tr ( E ) ) for any expression E in the text in A") #$BaseKB)
(f "Defx:UniversallyQuantifiedSentence")
(a '(#$comment #$Defx:UniversallyQuantifiedSentence "quantified sentence whose quantifier is universal") #$BaseKB)
(f "Defx:Universe")
(a '(#$comment #$Defx:Universe "structure consisting of a set UI superset of N , and two mappings relI from UI to subsets of UI * and funI from UI to functions from UI * to UI ; and a mapping intI , on V from VN to UI and from VS to UI *") #$BaseKB)
(f "Defx:VocabularyOfACommonLogicText")
(a '(#$comment #$Defx:VocabularyOfACommonLogicText "set of names and sequence markers which occur in the text") #$BaseKB)
(f "Defx:Hyperreals")
(a '(#$comment #$Defx:Hyperreals "uid35462 each layer corresponding to a family of parallel lines ( for some slope @ gateway / web / irccloud.com / x - plpmucfvwfqeehel ) Quit ( Quit : Connection closed for inactivity") #$BaseKB)
(f "Defx:ActArgue")
(a '(#$comment #$Defx:ActArgue "looks [ text mudEnergy mudEnergy , -11 , -20 ) , pir ( mudFun , 20 , 10 ) , pir ( mudSadToHappy , -10 , -10 ) , pir ( mudEnergy , 0 , -10 ) , pir ( mudNonLonelinessSocial , 10 , 15 ) , -11 , -20 ) , pir ( mudFun , 20 , 10 ) , pir ( mudSadToHappy , 0 , -10 ) , pir ( mudEnergy , 0 , -10 ) , pir ( mudNonLonelinessSocial , 10 , 15 ) ] ] ) , '' Prolog looks like : actAttack ( tAgent ) '' ] actAttack ( vtDirection ) ( [ verb_for_type , actBumpIntoBarrier , tFurniture , [ pir ( mudFun , -300 , 0 ) , pir ( mudEnergy , -300 , 0 ) , pir ( mudComfort , -300 , 0 ) , pir ( mudHygiene , -300 , 0 ) , pir ( mudNonLonelinessSocial , -300 , 0 ) ] ] ) , '' Prolog looks like : actBumpIntoBarrier verb_for_type , actClean , tLookAble , [ pir ( mudEnergy , 0 , -1 ) , pir ( mudFun , -2 , 2 ) ] ] ) , '' Prolog looks like : actClean ( tLookAble ) '' ] actClean ( tShower ) like : actClimb ( vtDirection ) '' actCmdparse ( ftListFn ( ftTerm ) ) = '' Development test to parse some Text for a human") #$BaseKB)
(f "Defx:IsOptionalTEatAbleActSet")
(a '(#$comment #$Defx:IsOptionalTEatAbleActSet "Lists [ reinterps looks tStowAble text [ verb_for_type , actSit , tCouch , [ pir ( mudEnergy , 10 , 20 ) , pir ( mudComfort , 20 , 20 ) ] ] ) , '' Prolog looks like : actSit ( tCouch ) '' ] actSit ( tSitAble ) = [ ` ` Sit on '' , text ( [ verb_for_type , actSit , tSitAble , [ pir ( mudSecureRoom , 1 , 1 ) , pir ( mudFun , 1 , 1 ) , pir ( mudComfort , 1 , 0 ) ( [ verb_for_type , actSleep , tLayAble , [ pir ( mudEnergy , 20 , 20 ) , pir ( mudComfort , 5 , 5 ) ] ] ) , '' Prolog looks like : actSleep ( tLayAble ) '' ] actSleep ( tMattress ) = [ ` ` Sleep a few '' , text ( [ verb_for_type , actSleep , tMattress , [ pir ( mudEnergy , 100 , 80 ) , pir ( mudComfort , 10 , 30 ) ] ] ) , '' Prolog looks like : actSleep ( tMattress ) '' ] actSpawn ( A ) ) , ( ? genlPreds ( B , mudControls ) ) , -t ( B , C , A ) , + mudStowing ( C , A ) ] ) actTake like : actTake ( tReadAble ) '' ] actTalk ( tAgent ) = [ ` ` Talk to '' , text ( [ verb_for_type , actTalk , tAgent , [ pir ( mudNonLonelinessSocial , 11 , 20 ) , pir ( mudFun , 1 , 1 ) , pir ( mudNonLonelinessSocial , 10 , 15 ) ] ] ) , '' Prolog looks like : actTalk ( tAgent ) '' ] actTeleport ( isOptional ( isAnd ( [ tObj , isNot ( tRegion ) ] ) , isSelfAgent ) , isOptionalStr ( ` ` to '' ) , isOptional ( tRegion , isRandom ( tRegion ) ) ) = '' teleport [ obj ] [ to ] [ somewhere ] '' actTest ( ftTerm ) = '' run tests containing term '' actTestStow ( _ ) = txtConcatFn ( makes , happen , [ ( ? mudPossess ( C , A ) ) , ( ? tStowAble ( A ) ) , ( ? genlPreds ( B , mudControls ) ) , -t ( B , C , A ) , + mudStowing ( C , A ) ] ) actTestUse ( _ ) = txtConcatFn ( makes , happen , [ ( ? mudPossess ( B , A ) ) , ( ? tUseAble ( A ) ) , ( ? mudStowing ( B , A ) ) , + using ( B , A ) ] ) a term as text '' actThinkAbout ( tLookAble ) = [ ` ` Think about '' , text ( [ verb_for_type , actThinkAbout , tLookAble , [ pir ( mudFun , 1 , 2 ) ] ] ) , '' Prolog looks like : actThinkAbout ( tLookAble ) '' ] actTick= '' Makes * your * agent do something brilliant '' actTick ( tAgent ) = '' Makes some agent do something brilliant '' actTickle ( tAgent ) = [ ` ` Play with '' , text ( [ verb_for_type , actTickle , tAgent , [ pir ( mudFun , 20 , 10 ) , pir ( mudEnergy , -10 , -10 ) ] ] ) , '' Prolog looks like : actTickle ( tAgent ) '' ] actTock= '' Makes All NPCs do something brilliant '' actTouch verb_for_type , actTouch , tTouchAble , [ pir ( mudSecureRoom , 1 , 1 ) , pir ( mudFun , 1 , 1 ) ] ] ) , '' Prolog looks like : actTouch ( tTouchAble ) '' ] actTravelThru ( tPassable ) = '' Prolog looks like : actTravelThru ( tPassable ) '' actUseTest ( _ ) = txtConcatFn ( makes , happen , [ ( ? mudPossess ( B , A ) ) , ( ? tUseAble ( A ) ) , ( ? mudStowing ( B , A ) ) , + using ( B , A ) ] ) actWhere ( ftTerm ) = '' Tells where something is '' actWho") #$BaseKB)
(f "Defx:TRadio")
(a '(#$comment #$Defx:TRadio "wash [ verb_for_type Move mudComfort Makes [ Drink a Drinkable Item '' actDrop verb_for_type , actEat , tEatAble , [ pir ( mudHygiene , 0 , -10 ) , pir ( mudNonHunger , 100 , 100 ) ] ] ) , '' nourish oneself '' ] actExamine ( tItem ) = '' view details of item ( see also @ ftListFn ) '' actExcersize ( tSitAble ) = [ ` ` Excersize '' , text ( [ verb_for_type , actExcersize , tSitAble , [ pir ( mudHygiene , -10 , -10 ) , pir ( mudFun , 10 , 10 ) ] ] ) , '' Prolog looks like : actExcersize ( tSitAble ) '' ] actGet ( isOptional ( some agent ( or self ) think of something brilliant '' actInventory ( isOptional ( tAgent , isSelfAgent ) ) = '' Examine an inventory '' actKiss ( tAgent ) = [ ` ` Kiss '' , text ( [ verb_for_type , actKiss , tAgent , [ pir ( mudFun , 21 , 20 ) , pir ( mudNonLonelinessSocial , 11 , 20 ) , pir ( mudFun , 10 , 10 ) , pir ( mudSadToHappy , 10 , 10 ) , pir ( mudNonLonelinessSocial , 10 , 15 ) ] ] ) , '' Prolog looks like : actKiss , 0 , -1 ) , pir ( mudSadToHappy , 0 , -1 ) , pir ( mudFun , 0 , -1 ) , pir ( mudNonLonelinessSocial , 0 , -1 ) , pir ( mudSecureRoom , 0 , -1 ) , pir ( mudHygiene , 0 , -1 ) , pir ( mudBladderEmpty , 0 , -1 ) , pir ( mudNonHunger , 0 , -1 ) , pir ( mudEnergy , 0 , -1 ) ] ] ) , '' Prolog looks like : actLiveAtLeastAMinute ( tSelfAgent ) '' ] actLogin ( isOptional ( tAgent , isRandom ( tAgent ) ) ) = '' ( Re ) Login and assume the role of an agent '' actLogout [ n=1 ] distance in direction '' actNpcTimer ( ftInt ) = '' sets how often to let NPCs run '' actObserve ( tArt ) = [ ` ` Apreciate the Art '' , text ( [ verb_for_type , actObserve , tArt , [ pir ( mudSecureRoom , 20 , 20 ) , pir ( mudFun , 10 , 10 ) ] ] ) , '' Prolog looks like : actObserve ( tArt ) '' ] actObserve , actObserve , tLookAble , [ pir ( mudEnergy , 0 , -1 ) , pir ( mudFun , 2 , 1 ) ] ] ) , '' Prolog looks like : actObserve ( tLookAble ) '' ] actObserve ( tMirror ) = [ ` ` Pop your zits '' , text ( [ verb_for_type , actObserve , tMirror , [ pir ( mudEnergy , 1 , -1 ) , pir ( mudSadToHappy , 10 , -1 ) , pir ( mudFun , 10 , 10 ) , pir ( mudSecureRoom , 1 , 0 ) ] ] ) , '' Prolog looks like : actObserve ( tMirror ) '' ] actObserve verb_for_type , actObserve , tRadio , [ pir ( mudEnergy , 1 , -1 ) , pir ( mudSadToHappy , 10 , 10 ) , pir ( mudFun , 10 , 10 ) , pir ( mudSecureRoom , 1 , 0 ) ] ] ) , '' Prolog looks like : actObserve ( tRadio ) '' ] actObserve ( tReadAble ) = [ ` ` Read book '' , text ( [ verb_for_type , actObserve , tReadAble , [ pir ( mudSecureRoom , 20 , 20 ) , pir ( mudFun , 10 , 10 ) ] ] ) , '' Prolog looks like : actObserve ( tReadAble ) '' ] actObserve ( tTelevision ) = [ text ( [ verb_for_type , actObserve , tTelevision , [ pir ( mudEnergy , 1 , -1 ) , pir ( mudSadToHappy , 2 , 1 ) , pir ( mudFun , 2 , 1 ) , pir ( mudSecureRoom , 1 , 0 ) , pir ( mudHygiene , 0 , 0 ) , pir ( self with X '' , text ( [ verb_for_type , actOperate , tBathtub , [ pir ( mudHygiene , 100 , 100 ) , pir ( mudComfort , 20 , 20 ) ] ] ) , '' Prolog looks like : actOperate ( tBathtub ) '' ] actOperate ( tClothesDryer ) = [ ` ` Dry The Clothes '' , text ( [ verb_for_type , actOperate , tClothesDryer , [ pir ( mudHygiene , 10 , 10 ) , pir ( mudComfort , 0 , 0 ) ] ] ) , '' Prolog looks like : actOperate ( tClothesDryer ) '' ] actOperate ( tComputer ) = [ ` ` Look busy doing something ! '' , '' Prolog looks like : actOperate ( tComputer ) '' ] actOperate") #$BaseKB)
(f "Defx:PFCInferenceRules")
(a '(#$comment #$Defx:PFCInferenceRules "Prolog terms which are asserted as facts into the regular Prolog database") #$BaseKB)
(a '(#$comment #$Defx:PFCInferenceRules "Prolog terms which are asserted as clauses into the regular Prolog database") #$BaseKB)
(f "Defx:PFCSystem")
(a '(#$comment #$Defx:PFCSystem "package that provides a forward reasoning capability to be used together with conventional Prolog programs") #$BaseKB)
(f "Defx:PfcSystem")
(a '(#$comment #$Defx:PfcSystem "records a justification for the conclusion which , in this case , states that it depends on the absence of the contradictory evidence") #$BaseKB)
(f "Defx:InferenceEngine")
(a '(#$comment #$Defx:InferenceEngine "computer program that tries to derive answers from a knowledge base") #$BaseKB)
(f "Defx:PfcTmsMode")
(a '(#$comment #$Defx:PfcTmsMode "fact is removed if it has no supporting justifications") #$BaseKB)
(f "Defx:Action_info")
(a '(#$comment #$Defx:Action_info "use ( A ) , text ( [ makes , happen , [ possess ( an ( agent ) , A ) , isa ( A , useable ) , ( stowed ( an ( agent ) , A ) - > using ( an ( agent ) , A ) ) ] ] ) , agent ) action_info ( wear ( wearable ) , '' wear a wearable that you are / have stowed so it will be wearsClothing") #$BaseKB)
(f "Defx:Action_infoAction_info")
(a '(#$comment #$Defx:Action_infoAction_info "text ( [ parsetemps ] , ' does : ' , do ( A , parsetemps ( [ ] ) ) ) , isaFn ( A )") #$BaseKB)
(f "Defx:Action_infoAction_infoAction_info")
(a '(#$comment #$Defx:Action_infoAction_infoAction_info "@ create ( list ( term ) ) , '' Rezes a new ' spatialthing ' or creates a new ' type ' of some NameOrType and if it 's an ' item ' it will put in stowed inventory '' , _ ) explorer set ' ( A , B , C ) , text ( file , ' /devel / logicmoo / src_incoming / actions / get_set.pl ' , contains , ' @ set ' ( A , B , C ) ) , _ ) action_info ( ' @ set ' ( optional ( term , self ) , atom , term ) , text ( ` ` @ sets term to a property '' ) , _ ) action_info ( ask ( optional ( channel , here ) , string ) , text ( ` ` invokes '' , chat ( optional ( verb , ask ) , optional ( channel , here ) , string ) ) , _ ) action_info ( attack ( dir ) , text ( ` ` command is : ` ` , attack ( dir ) ) , _ ) action_info ( attack ( A ) , text ( file , ' /devel / logicmoo / src_incoming / actions / attack.pl ' , contains , attack ( A ) ) , _ ) action_info ( chat80 ( [ ] ) , text ( file , ' /devel / logicmoo / src_incoming / parsing / parser_chat80.pl ' , contains , chat80 ( [ ] ) ) , _ ) action_info ( chat80 ( A ) , text ( file , ' /devel / logicmoo / src_incoming / parsing / parser_chat80.pl ' , contains , chat80 ( A ) ) , _ ) action_info ( chat80 ( list ( term ) ) , '' Development test CHAT-80 Text for a human") #$BaseKB)
(f "Defx:Action_infoAction_infoAction_infoAction_info")
(a '(#$comment #$Defx:Action_infoAction_infoAction_infoAction_info "Lists whisper ( who is online ( where they are at least ) '' , _ ) action_info ( wield ( wieldable ) , '' wield a wieldable that you are / have stowed so it will be wielding") #$BaseKB)
(f "Defx:Action_infoAction_infoAction_infoAction_infoAction_infoAction_info")
(a '(#$comment #$Defx:Action_infoAction_infoAction_infoAction_infoAction_infoAction_info "text rename contains user text text parsetemps ( [ A , B ] ) , text ( [ parsetemps , A , B ] , ' does : ' , do ( C , parsetemps ( [ A , B ] ) ) ) , isaFn ( C ) ) ( [ parsetemps , A , B , C ] , ' does : ' , do ( D , parsetemps ( [ A , B , C ] ) ) ) , isaFn ( D ) ) ( [ parsetemps , A , B , C , D ] , ' does : ' , do ( E , parsetemps ( [ A , B , C , D ] ) ) ) , isaFn ( E ) ) action_info ( prolog ( prolog ) , '' Call prolog toploop '' , _ ) action_info ( prolog ( A ) , text ( file , ' /devel / logicmoo / src_incoming / vworld / toploop_npc.pl ' , contains , prolog ( A ) ) , _ ) action_info ( prologCall ( someCode ) , text ( [ prolog , someCode ] , ' does : ' , do ( A , prologCall ( someCode ) ) ) , isaFn ( A ) ) : prolog_repl ) , text ( file , ' /devel / logicmoo / src_incoming / vworld / toploop_npc.pl ' , contains , prologCall ( user : prolog_repl ) ) , _ ) action_info ( prologCall ( user : tlocals ) , text ( file , ' /devel / logicmoo / src_incoming / vworld / toploop_npc.pl ' , contains , prologCall ( user : tlocals ) ) , _ ) action_info ( push ( dir ) , text ( ` ` command is : ` ` , push ( dir ) ) , _ ) action_info ( , push ( A ) ) , _ ) action_info ( quit , '' logs out of game ( quits ) '' , _ ) action_info ( string ) , '' Rename your player '' , _ ) action_info ( rename ( A ) , text ( file , ' /devel / logicmoo / src_incoming / actions / logon.pl ' , contains , rename ( A ) ) , _ ) action_info ( rez ( term ) , '' Rezes a new ' item ' of some NameOrType into stowed inventory '' , _ ) action_info ( rez ( A ) , text ( file , ' /devel / logicmoo / src_incoming / actions / create.pl ' , contains , rez ( A ) ) , _ ) ( ` ` invokes '' , chat ( optional ( verb , shout ) , optional ( channel , here ) , string ) ) , _ ) action_info ( sit , text ( ` ` sets and agent 's stance to ` ` , sit ) , _ ) action_info ( spawn ( prey ) , text ( file , ' /devel / logicmoo / src_incoming / mobs / prey.pl ' , contains , spawn ( prey ) ) , _ ) action_info ( spawn ( type ) , text ( ` ` command is : ` ` , spawn ( type ) ) , _ ) action_info ( stand , text ( ` ` sets and agent 's stance to ` ` , stand ) , _ ) action_info ( stats ( A ) , text ( file , ' /devel / logicmoo / src_incoming / actions / stats.pl ' , contains , stats ( A ) ) , _ ) action_info ( stats ( optional ( term , self ) ) , '' Examine MUD stats of something '' , _ ) action_info ( stow ( stowable ) , '' stow a stowable that you are / have holding so it will be stowed") #$BaseKB)
(f "Defx:ClientProgram")
(a '(#$comment #$Defx:ClientProgram "simply another program you use instead of telnet to connect to a mud") #$BaseKB)
(f "Defx:Teleport_toAction_info")
(a '(#$comment #$Defx:Teleport_toAction_info "tests contains stow ( A ) , text ( [ makes , happen , ( [ possess ( an ( agent ) , A ) , isa ( A , stowable ) , genlPreds ( B , controls ) , [ B , an ( agent ) , A ] ] - > [ stowed , an ( agent ) , A ] ) ] ) , agent ) action_info ( take ( item ) , text ( ` ` command is : ` ` , take ( item ) ) , _ ) action_info , teleport_to ( self , A ) ) , _ ) action_info ( teleport_to ( A , B ) , text ( file , ' /devel / logicmoo / src_incoming / actions / teleport.pl ' , contains , teleport_to ( A , B ) ) , _ ) action_info ( tell ( optional ( channel , here ) , string ) , text ( ` ` invokes '' , chat ( optional ( verb , tell ) , optional ( channel , here ) , string ) ) , _ ) action_info ( test ( term ) , '' run tests containing term '' , _ ) action_info ( , '' run run_mud_tests/ : '' , _ ) action_info ( tick , '' Makes * your * agent do something brilliant '' , _ ) action_info ( tick ( agent ) , '' Makes some agent do something brilliant '' , _ ) action_info ( tick ( A ) , text ( file , ' /devel / logicmoo / src_incoming / vworld / toploop_npc.pl ' , contains , tick ( A ) ) , _ ) action_info ( tock , '' Makes All NPCs do something brilliant '' , _ ) action_info ( tp ( A ) , text ( file , ' /devel / logicmoo / src_incoming / actions / teleport.pl ' , contains , tp ( A ) ) , _ ) action_info ( use ( usable ) , '' use a usable that you are / have stowed so it will be using") #$BaseKB)
(f "Defx:Agent")
(a '(#$comment #$Defx:Agent "only agent that ever performs ( in the past , present or future ) the actions which appear in action expression a , Single ( a ) means that a denotes an action expression that is not a sequence") #$BaseKB)
(f "Defx:DescriptionAgree")
(a '(#$comment #$Defx:DescriptionAgree "general - purpose agreement to a previously submitted request to perform some action") #$BaseKB)
(f "Defx:DescriptionCancel")
(a '(#$comment #$Defx:DescriptionCancel "allows an agent i to inform another agent j that i no longer intends that j perform a previously requested action") #$BaseKB)
(f "Defx:DescriptionCfp")
(a '(#$comment #$Defx:DescriptionCfp "general - purpose action to initiate a negotiation process by making a call for proposals to perform the given action") #$BaseKB)
(f "Defx:DescriptionFailure")
(a '(#$comment #$Defx:DescriptionFailure "abbreviation for informing that an act was considered feasible by the sender , but was not completed for some given reason") #$BaseKB)
(f "Defx:DescriptionPropose")
(a '(#$comment #$Defx:DescriptionPropose "general - purpose act to make a proposal or respond to an existing proposal during a negotiation process by proposing to perform a given action subject to certain conditions being true") #$BaseKB)
(f "Defx:DescriptionQuery")
(a '(#$comment #$Defx:DescriptionQuery "act of asking another agent whether ( it believes that ) a given proposition is true") #$BaseKB)
(f "Defx:DescriptionReject-Proposal")
(a '(#$comment #$Defx:DescriptionReject-Proposal "general - purpose rejection to a previously submitted proposal") #$BaseKB)
(f "Defx:DescriptionRequest")
(a '(#$comment #$Defx:DescriptionRequest "allows an agent to inform another agent that a certain action should be performed as soon as a given precondition , expressed as a proposition , becomes true") #$BaseKB)
(f "Defx:FoundationForIntelligentPhysicalAgents")
(a '(#$comment #$Defx:FoundationForIntelligentPhysicalAgents "international organization that is dedicated to promoting the industry of intelligent agents by openly developing specifications supporting interoperability among agents and agent - based applications") #$BaseKB)
(a '(#$comment #$Defx:FoundationForIntelligentPhysicalAgents "international organization that is dedicated to promoting the industry of intelligent agents by openly developing specifications supporting interoperability among agents and agent - based applications") #$BaseKB)
(f "Defx:Intention")
(a '(#$comment #$Defx:Intention "persistent goal imposing the agent to act") #$BaseKB)
(f "Defx:MessageContent")
(a '(#$comment #$Defx:MessageContent "action expression denoting the action that is no longer intended") #$BaseKB)
(a '(#$comment #$Defx:MessageContent "tuple consisting of an action description and a proposition which formed the original proposal being rejected , and a further proposition which denotes the reason for the rejection") #$BaseKB)
(f "Defx:OpenQuestionCaseOpenQuestion")
(a '(#$comment #$Defx:OpenQuestionCaseOpenQuestion "question which does not suggest a choice and , in particular , which does not require a yes / no answer") #$BaseKB)
(f "Defx:Propositions")
(a '(#$comment #$Defx:Propositions "statements expressing that some sentence in a language is true or false") #$BaseKB)
(f "Defx:RDFSchemas")
(a '(#$comment #$Defx:RDFSchemas "provides a typing system for the resources and properties used in the RDF data") #$BaseKB)
(f "Defx:RDFDescription")
(a '(#$comment #$Defx:RDFDescription "specific resource together with one or more named properties plus the values of these properties collection of RDF statements") #$BaseKB)
(f "Defx:RefuseSummary")
(a '(#$comment #$Defx:RefuseSummary "action of refusing to perform a given action , and explaining the reason for the refusal") #$BaseKB)
(f "Defx:SemanticLanguage")
(a '(#$comment #$Defx:SemanticLanguage "formal language used to define the semantics of the FIPA ACL") #$BaseKB)
(f "Defx:UififUifUiFUifif")
(a '(#$comment #$Defx:UififUifUiFUifif "either") #$BaseKB)
(f "Defx:AbilityPreconditions")
(a '(#$comment #$Defx:AbilityPreconditions "characterise the intrinsic ability of an agent to perform a given CA") #$BaseKB)
(f "Defx:Accept-Proposal")
(a '(#$comment #$Defx:Accept-Proposal "general - purpose acceptance of a proposal that was previously submitted ( typically through a propose act )") #$BaseKB)
(f "Defx:Action")
(a '(#$comment #$Defx:Action "agent - identifier : name j ) : receiver ( set ( agent - identifier : name i ) ) : content \ '' < fipa - ccl content expression > \ '' : ontology www : language fipa - ccl") #$BaseKB)
(a '(#$comment #$Defx:Action "agent service - description : name agent - brokerage ) ) ) - identifier : name i") #$BaseKB)
;; (f "Defx:ActionContent``")
;; (a '(#$comment #$Defx:ActionContent`` "agent agent request : sender ( agent - identifier : name i ) : receiver ( set ( agent - identifier : name j ) - identifier : name j - identifier : name j ) : receiver ( set ( agent - identifier : name i action of one agent informing another agent that the first agent no longer has the intention that the second agent performs some action") #$BaseKB)
;; (a '(#$comment #$Defx:ActionContent`` "agent agent - identifier : name i ) : receiver ( set ( agent - identifier : name j ) - identifier : name j ) : receiver ( set ( agent - identifier : name i ) ) : content \ '' in ( lannion , normandy ) \ '' : language Prolog ) ) ) '' : language fipa - sl") #$BaseKB)
(f "Defx:Actor")
(a '(#$comment #$Defx:Actor "identifies the entity responsible for the execution of the action , that is , the value is the specific entity which will / can / should perform the act ( often the receiver , but possibly another agent / entity under ` ` control '' of the receiver )") #$BaseKB)
(f "Defx:AgentPerformingTheQuery-IfAct")
(a '(#$comment #$Defx:AgentPerformingTheQuery-IfAct "has no knowledge of the truth value of the proposition , and , believes that the other agent can inform the querying agent if it knows the truth of the proposition") #$BaseKB)
(f "Defx:AgentPerformingTheQuery-RefAct")
(a '(#$comment #$Defx:AgentPerformingTheQuery-RefAct "does not know which object or set of objects corresponds to the descriptor , and , believes that the other agent can inform the querying agent the object or set of objects that correspond to the descriptor") #$BaseKB)
(f "Defx:Argument")
(a '(#$comment #$Defx:Argument "identifies an ( optional ) entity which can be used for the execution of the action ; that is , the value is entity which is used by the actor to perform the act") #$BaseKB)
(f "Defx:BrokeringRequestBrokerageAgent")
(a '(#$comment #$Defx:BrokeringRequestBrokerageAgent "protocol parameter is set to fipa - brokering receiver of the proxy message") #$BaseKB)
(f "Defx:Cancel")
(a '(#$comment #$Defx:Cancel "used to let an agent know that another agent no longer has a particular intention") #$BaseKB)
(f "Defx:ConformanceTesting")
(a '(#$comment #$Defx:ConformanceTesting "demonstrating in an unambiguous way that a given agent implementation is correct with respect to this formal model") #$BaseKB)
;; (f "Defx:Content``")
;; (a '(#$comment #$Defx:Content`` "agent agent - identifier : name j - identifier : name j ) : receiver ( set ( agent - identifier : name i") #$BaseKB)
;; (a '(#$comment #$Defx:Content`` "agent - identifier : name j") #$BaseKB)
(f "Defx:ContentOfTheMessage")
(a '(#$comment #$Defx:ContentOfTheMessage "description of the action to be performed , in some language the receiver understands") #$BaseKB)
(f "Defx:Context-RelevancePreconditions")
(a '(#$comment #$Defx:Context-RelevancePreconditions "characterise the relevance of the act to the context in which it is performed") #$BaseKB)
(f "Defx:Descriptor")
(a '(#$comment #$Defx:Descriptor "referential expression") #$BaseKB)
(a '(#$comment #$Defx:Descriptor "referential expression") #$BaseKB)
(f "Defx:DescriptorACLCommunicativeAct")
(a '(#$comment #$Defx:DescriptorACLCommunicativeAct "referential expression , that denotes the target agents ACL message , to be performed to the agents , and a constraint condition for performing the embedded communicative act , for example , the maximum number of agents to be forwarded , etc") #$BaseKB)
(f "Defx:DescriptorEmbeddedACLCommunicativeAct")
(a '(#$comment #$Defx:DescriptorEmbeddedACLCommunicativeAct "referential expression , denoting an agent or agents to be forwarded the propagate message ACL message , performed by the sender to the receiver of the propagate message and a constraint condition for propagation , for example , a timeout") #$BaseKB)
(f "Defx:DirectQuestion")
(a '(#$comment #$Defx:DirectQuestion "question underlain by a plan which is limited to the reaction strictly legitimised by the question") #$BaseKB)
(f "Defx:Disconfirm")
(a '(#$comment #$Defx:Disconfirm "sending agent : believes that some proposition is false , intends that the receiving agent also comes to believe that the proposition is false , and , believes that the receiver either believes the proposition , or is uncertain of the proposition") #$BaseKB)
(f "Defx:Inform-RefMacroAction")
(a '(#$comment #$Defx:Inform-RefMacroAction "allows the sender to inform the receiver some object that the sender believes corresponds to a descriptor , such as a name or other identifying description") #$BaseKB)
(f "Defx:InformAct")
(a '(#$comment #$Defx:InformAct "when the act is actually performed , what is sent and what can be said to be Done") #$BaseKB)
(f "Defx:Inter-AgentPlan")
(a '(#$comment #$Defx:Inter-AgentPlan "sequence of such communicative acts , using either composition operator , involving two or more agents") #$BaseKB)
(f "Defx:Knowledge")
(a '(#$comment #$Defx:Knowledge "used as an abbreviation for believes or is uncertain of") #$BaseKB)
(f "Defx:Langue")
(a '(#$comment #$Defx:Langue "domain rdf : resource= '' # Action '' / > < /rdfs : ConstraintProperty > < rdfs : Class rdf : ID= '' Code '' > < rdfs : label xml : lang= '' en '' > code < /rdfs : label > < rdfs : label xml : lang= '' fr ''") #$BaseKB)
(f "Defx:Not-UnderstoodMessage")
(a '(#$comment #$Defx:Not-UnderstoodMessage "misunderstood , action that nothing has been done as a result of the message") #$BaseKB)
(f "Defx:ObjectProperty")
(a '(#$comment #$Defx:ObjectProperty "identifies the property value in the original statement ; that is , the value is the object in the original statement") #$BaseKB)
(f "Defx:PredicateProperty")
(a '(#$comment #$Defx:PredicateProperty "identifies the property of the original statement ; that is , the value is the specific property in the original statement") #$BaseKB)
(f "Defx:PropertyCode-Uri")
(a '(#$comment #$Defx:PropertyCode-Uri "reference to the location of code where the method or function can be found ( for Java a code base followed by a class name )") #$BaseKB)
(f "Defx:Query-IfAct")
(a '(#$comment #$Defx:Query-IfAct "requires the agent performing it not to have any knowledge about the proposition whose truth value is asked for") #$BaseKB)
(f "Defx:RefDescriptionQuery")
(a '(#$comment #$Defx:RefDescriptionQuery "act of asking another agent to inform the requester of the object identified by a descriptor") #$BaseKB)
(f "Defx:RefuseAct")
(a '(#$comment #$Defx:RefuseAct "abbreviation for denying ( strictly speaking , disconfirm ) that an act is possible for the agent to perform and stating the reason why that is so") #$BaseKB)
(a '(#$comment #$Defx:RefuseAct "performed when the agent can not meet all of the preconditions for the action to be carried out , both implicit and explicit") #$BaseKB)
(f "Defx:ReifiedStatementSubjectProperty")
(a '(#$comment #$Defx:ReifiedStatementSubjectProperty "identifies the resource being described by the modelled statement ; that is , the value of this property is the resource about which the original statement was made") #$BaseKB)
(f "Defx:Request")
(a '(#$comment #$Defx:Request "represents a persistent commitment to re - evaluate the given proposition and take action when its value changes") #$BaseKB)
;; (f "Defx:Selection-Result''")
;; (a '(#$comment #$Defx:Selection-Result'' "container filled with selection results < /rdfs : comment > < rdfs : domain rdf : resource= '' Rule '' / > < rdfs : range rdf : resource=") #$BaseKB)
(f "Defx:Sender")
(a '(#$comment #$Defx:Sender "informs the receiver that a given proposition is true , where the receiver is known to be uncertain about the proposition") #$BaseKB)
(a '(#$comment #$Defx:Sender "informs the receiver that a given proposition is false , where the receiver is known to believe , or believe it likely that , the proposition is true") #$BaseKB)
;; (f "Defx:SetContent``")
;; (a '(#$comment #$Defx:SetContent`` "agent agent - identifier : name j ) : receiver ( set ( agent - identifier : name i - identifier : name i ) ) : content [ 2 ] \ '' ( ( action ( agent - identifier : name i") #$BaseKB)
(f "Defx:SubscribeAct")
(a '(#$comment #$Defx:SubscribeAct "persistent version of query - ref , such that the agent receiving the subscribe will inform the sender of the value of the reference and will continue to send further informs if the object denoted by the description changes") #$BaseKB)
(f "Defx:Tuple")
(a '(#$comment #$Defx:Tuple "consisting of an action expression denoting the action to be done , and a proposition giving the conditions of the agreement") #$BaseKB)
(a '(#$comment #$Defx:Tuple "consisting of an action expression and a proposition giving the reason for the refusal") #$BaseKB)
(f "Defx:WeakProxying")
(a '(#$comment #$Defx:WeakProxying "we") #$BaseKB)
(a '(#$comment #$Defx:WeakProxying "can be expressed as an instance of proxy where the action < j , cact ( y ) > is replaced by < j , inform ( y , Ii Done ( < i , cact ( y ) > ) ) >") #$BaseKB)
(f "Defx:DirectionsDirection")
(a '(#$comment #$Defx:DirectionsDirection "value associated with every assertion that determines when inferencing involving that assertion should be performed") #$BaseKB)
(f "Defx:NAT")
(a '(#$comment #$Defx:NAT "using a NAT which has a variable as one of its arguments") #$BaseKB)
(f "Defx:NATTermOfUnitNAT-CONSTANTNAT-EXPRESSION-CONSTANT")
(a '(#$comment #$Defx:NATTermOfUnitNAT-CONSTANTNAT-EXPRESSION-CONSTANT "non - atomic term that can be used to refer to it") #$BaseKB)
(f "Defx:Y")
(a '(#$comment #$Defx:Y "any two things owned by Fred are near each other") #$BaseKB)
(f "Defx:AssertTime")
(a '(#$comment #$Defx:AssertTime "when a new assertion is added to the KB") #$BaseKB)
(f "Defx:DeDictoequivalent")
(a '(#$comment #$Defx:DeDictoequivalent "NAT is identified with a atom using termOfUnit") #$BaseKB)
(f "Defx:GroundAtomicFormulaAtomicFormulas")
(a '(#$comment #$Defx:GroundAtomicFormulaAtomicFormulas "formula in which the ARG0 position is occupied by a predicate , and all the other argument positions are filled with terms : ( likesAsFriend DougLenat KeithGoolsbey ) ( skillCapableOf LinusVanPelt PlayingAMusicalInstrument performedBy ) ( colorOfObject ? CAR ? COLOR") #$BaseKB)
(f "Defx:Impliesassertion")
(a '(#$comment #$Defx:Impliesassertion "says only that either the first argument is false , or the second argument is true") #$BaseKB)
(f "Defx:MotherOf")
(a '(#$comment #$Defx:MotherOf "Woman , Child )") #$BaseKB)
;; (f "Defx:MtProlog/1")
;; (a '(#$comment #$Defx:MtProlog/1 "contains prologBuiltin/1s and prologDynamic/1s mtCycL/1 contain only subclasses of prologHybrid/1s Implicit assertions in baseKB for operations inside those microtheories") #$BaseKB)
(f "Defx:Non-AtomicTerm")
(a '(#$comment #$Defx:Non-AtomicTerm "way of specifying a termas a function of some other term ( s )") #$BaseKB)
(f "Defx:PrimitiveNarrativeEvents")
(a '(#$comment #$Defx:PrimitiveNarrativeEvents "story containing language designed by the environment trying to create a way to describe a virtual world in terms that a non - programmer could use , rather than limiting the future by only allowing programmers to create virtual worlds ( like MUDs ) Skip to main cont") #$BaseKB)
(f "Defx:Support")
(a '(#$comment #$Defx:Support "consists of one or more justifications which form the support for the presence of the assertion in the KB") #$BaseKB)
(a '(#$comment #$Defx:Support "one element of an assertion which need not be specified by the KEer when performing knowledge entry") #$BaseKB)
(f "Defx:SupportingJustification")
(a '(#$comment #$Defx:SupportingJustification "source which indicates the assertion was inferred and which outlines the final step of some argument , or chain of reasoning , which supports the assertion") #$BaseKB)
(f "Defx:RegistrationPredicates")
(a '(#$comment #$Defx:RegistrationPredicates "Used to declare that some predicates defined in a module file are special and contribute overall to the implementation World Command Modules : - register_command_module") #$BaseKB)
(f "Defx:Symbols")
(a '(#$comment #$Defx:Symbols "how Methods References that can be distinguished from one another such : doe , ra , me , fa , so are five different symbols Tuple of grouping symbols many symbols must appear in a statement") #$BaseKB)
(f "Defx:Action")
(a '(#$comment #$Defx:Action "implies ( and ( isa ? Action TakingPartOfObject") #$BaseKB)
(f "Defx:GROUPB")
(a '(#$comment #$Defx:GROUPB "With a minor genetic alteration ( a single gene ) these spiders can be made to keep all of their traits that they have except now they can build a sticky web") #$BaseKB)
(f "Defx:BusSpeed")
(a '(#$comment #$Defx:BusSpeed "different people / animals have a different amount of time in which it takes these tracers to disappear") #$BaseKB)
(f "Defx:Dams")
(a '(#$comment #$Defx:Dams "built specifically to create shading pools for fish") #$BaseKB)
(f "Defx:Umwelt")
(a '(#$comment #$Defx:Umwelt "all insect or animal , human or otherwise , moves through its environment the senses collect data that are made available to the brain") #$BaseKB)
(f "Defx:MagneticPulse")
(a '(#$comment #$Defx:MagneticPulse "used to clear out the buggered script") #$BaseKB)
(f "Defx:NarrativeBlog")
(a '(#$comment #$Defx:NarrativeBlog "describes how and why we are doing and thinking") #$BaseKB)
(f "Defx:Storify-")
(a '(#$comment #$Defx:Storify- "ing the details of the information it is receiving") #$BaseKB)
;; (f "Defx:Unwind/Unbind")
;; (a '(#$comment #$Defx:Unwind/Unbind "rolling back things to start over") #$BaseKB)
(f "Defx:SomeType")
(a '(#$comment #$Defx:SomeType "jill each skolem gets universally represented , skJill ( J , F , Y ) ) /\ someType ( skFish ( J , F , Y ) , fish ) /\ equals ( J , skJill ( J , F , Y ) ) /\ equals ( F , skFish ( J , F , Y ) ) - > loves ( skJill ( J , F , Y ) , Y ) /\ eats ( Y , skFish ( J , F , Y )") #$BaseKB)
(f "Defx:Openworld")
(a '(#$comment #$Defx:Openworld "have infinite numbers of true and false propositions") #$BaseKB)
(f "Defx:Being1")
(a '(#$comment #$Defx:Being1 "non - conscious with no ability to reason and articulate about mental contents through meta - reflection , reacting without explicitly realizing and without the meta - reflective ability to give an account of why one did so") #$BaseKB)
(f "Defx:Being2")
(a '(#$comment #$Defx:Being2 "meta consciousness , autobiographical memory , and the capacity for executive ` ` ego functions '' such as deliberate mind - wandering and conscious introspection of mental content") #$BaseKB)
(f "Defx:CriticalMass")
(a '(#$comment #$Defx:CriticalMass "concept that a certain amount of pre - existing animatory logic structures have to be in place and exist before a system can go out on its own and learn") #$BaseKB)
(f "Defx:DAYDREAMER")
(a '(#$comment #$Defx:DAYDREAMER "program that Is meant to use emotional controls in order to decide what CD - Theory ( AL ) to generate") #$BaseKB)
(f "Defx:Analog")
(a '(#$comment #$Defx:Analog "mental representation of yourself as a subject") #$BaseKB)
(f "Defx:BicameralMind")
(a '(#$comment #$Defx:BicameralMind "imagines that two beings dwell in the same brain") #$BaseKB)
(f "Defx:EpiConsciousnessConsciousnessPhenomenal")
(a '(#$comment #$Defx:EpiConsciousnessConsciousnessPhenomenal "period of the bicameral human being in the bicameral mind there was no consciousness there was just action commanded by hallucinated voices from another part of the brain that was believed to be a God yeah relationship between the sensation of experience and the actions in our body is a complete illusion our consciousness does not in fact control our body our body acts in our consciousness watches you act it 's a helpless passenger essentially watching a movie of our own mind place where consciousness happens or is made possible you they may be right it may be that you can isolate") #$BaseKB)
(f "Defx:HemisphericSleepNondominantHemisphere")
(a '(#$comment #$Defx:HemisphericSleepNondominantHemisphere "one players that are chess programs assisted by human players okay so it 's always liking of the chess program it basically knows what you all the time but maybe to introduce some novelty the human player steps in and does something clever ha two hemispheres of the brain the right hemisphere and left him hemisphere are genuinely divided and can in some senses act independently almost as if they were two separate persons acting kind of mind is better than another or even that one kind of mind is smarter than the other because that they do just seem to offer different adaptive capabilities") #$BaseKB)
(f "Defx:SpecializedSpecializationMetaphor")
(a '(#$comment #$Defx:SpecializedSpecializationMetaphor "things that do not in reality have a spatial quality") #$BaseKB)
(f "Defx:Determiner-Central")
(a '(#$comment #$Defx:Determiner-Central "Determiner - ClassA ' , ' Determiner - ClassB ' , ' Determiner - ClassC ' , ' ExpletivePronoun ' , ' IndefinitePronoun ' , ' Number - SP ' , ' ObjectPronoun ' , ' PossessivePronoun ' , ' PossessivePronoun - Post ' , ' Postdeterminer ' , ' Pronoun ' , ' Pronoun - SubjectOrObject ' , ' ReciprocalPronoun ' , ' ReflexivePronoun ' , ' SubjectPronoun ' , ' WHDeterminer ' , ' WHPronoun ' ] ] [ [ txt , costumes ] , [ tag , z , nns , ' CountNoun '") #$BaseKB)
(f "Defx:HIM")
(a '(#$comment #$Defx:HIM "PronounFn ThirdPerson - NLAttr Singular - NLAttr Masculine - NLAttr ObjectPronoun") #$BaseKB)
(a '(#$comment #$Defx:HIM "PronounFn ThirdPerson - NLAttr Singular - NLAttr Masculine - NLAttr ObjectPronoun") #$BaseKB)
(a '(#$comment #$Defx:HIM "PronounFn ThirdPerson - NLAttr Singular - NLAttr Masculine - NLAttr ObjectPronoun") #$BaseKB)
(f "Defx:PossessivePronoun-Post")
(a '(#$comment #$Defx:PossessivePronoun-Post "tag , staart , prp , ppss , ' Determiner ' , ' Determiner - Central ' , ' Determiner - ClassA ' , ' Determiner - ClassB ' , ' Determiner - ClassC ' , ' ExpletivePronoun ' , ' IndefinitePronoun ' , ' Number - SP ' , ' ObjectPronoun ' , ' PossessivePronoun ' , ' PossessivePronoun - Post ' , ' Postdeterminer ' , ' Pronoun ' , ' Pronoun - SubjectOrObject ' , ' ReciprocalPronoun ' , ' ReflexivePronoun") #$BaseKB)
(f "Defx:PossessivePronounPossessivePronoun-Post-Pre")
(a '(#$comment #$Defx:PossessivePronounPossessivePronoun-Post-Pre "Determiner tag , staart , dt , jj , nnp , pdt , rb , ' Adverb - ClassB ' , ' Determiner - ClassC ' , ' ExpletivePronoun ' , ' IndefinitePronoun ' , ' Number - SP ' , ' ObjectPronoun ' , ' PossessivePronoun ' , ' PossessivePronoun - Post ' , ' Postdeterminer ' , ' Pronoun ' , ' Pronoun - SubjectOrObject ' , ' ReciprocalPronoun") #$BaseKB)
(f "Defx:Preposition-Directional-Telic")
(a '(#$comment #$Defx:Preposition-Directional-Telic "Determiner - ClassA ' , ' Determiner - ClassB ' , ' Determiner - ClassC ' , ' Determiner - Indefinite ' , ' Postdeterminer ' , ' WHDeterminer ' , ' CountNoun ' , ' MassNoun ' , ' MassNoun - Generic ' ]") #$BaseKB)
(f "Defx:Sit")
(a '(#$comment #$Defx:Sit "` wants ( J , Sit0 ) , Sit0 = and ( txtDenotes ( ` the tallest man '' , Sit2 ) , Sit2 = compareForExtent ( Man , Rest , tHumanMale , mudHeight , greaterThan ) , txtDenotes (") #$BaseKB)
(f "Defx:TARGETAGENT")
(a '(#$comment #$Defx:TARGETAGENT "awareOf ? SPEAKER ? TARGETAGENT") #$BaseKB)
(f "Defx:True-JustificationTruth")
(a '(#$comment #$Defx:True-JustificationTruth "# $ genls # $ Coffee - Beverage # $ Drink ) TRUE ( # $ genls # $ Drink # $ LiquidTangibleThing ) TRUE ( # $ genls # $ LiquidTangibleThing # $ FluidTangibleThing ) TRUE ( # $ disjointWith # $ FluidTangibleThing # $ Agent - PartiallyTangible ) TRUE") #$BaseKB)
(f "Defx:GoalChangesMadeAvailable")
(a '(#$comment #$Defx:GoalChangesMadeAvailable "Promote1 She1 , Announced1 , increaseCausually ( SafetyLevel1 ) ) , goalChanges ( Promote1 , increaseCausually ( SafetyLevel2 ) ) ) ) )") #$BaseKB)
(f "Defx:AdaptiveBehavior")
(a '(#$comment #$Defx:AdaptiveBehavior "enables a child to get along in his or her environment with greatest success and least conflict with others") #$BaseKB)
(f "Defx:ApopheniaPatternMachines")
(a '(#$comment #$Defx:ApopheniaPatternMachines "who are motivated in some way towards seeing patterns whether they are there or not") #$BaseKB)
(f "Defx:AugmentedTransitionNetwork")
(a '(#$comment #$Defx:AugmentedTransitionNetwork "help guide ( a heuristicly divide what it focused on") #$BaseKB)
;; (f "Defx:NarrativeSequentialRecognitionCall/Response")
;; (a '(#$comment #$Defx:NarrativeSequentialRecognitionCall/Response "for every action there _ must _ be a punctuation") #$BaseKB)
(f "Defx:Unrealism")
(a '(#$comment #$Defx:Unrealism "codeword that points out fact that nothing we imagine is anymore unreal than anything else we imagined") #$BaseKB)
(f "Defx:Choice")
(a '(#$comment #$Defx:Choice "represents ideas that cause the least mental anguish a limit on freedom within an otherwise unbridled range of thoughts") #$BaseKB)
(f "Defx:Narrative")
(a '(#$comment #$Defx:Narrative "creates a conundrum whereby each of us exists , for as long as we live , within an overall condition of nothingness ( nothingness ) that ultimately allows for free consciousness") #$BaseKB)
(f "Defx:NarrativeBlog")
(a '(#$comment #$Defx:NarrativeBlog "describes how and why we doing and thinking what we are is doing and thinking") #$BaseKB)
(f "Defx:Stories")
(a '(#$comment #$Defx:Stories "Creates a story about the mental process of story creation it used") #$BaseKB)
;; (f "Defx:Unwind/Unwind")
;; (a '(#$comment #$Defx:Unwind/Unwind "rolling back things to start over") #$BaseKB)
(f "Defx:Merge_sort")
(a '(#$comment #$Defx:Merge_sort "List , Sorted ) : - List= [ _ , _ | _ ] , divide ( List , L1 , L2 ) , % list with at least two elements is divided into two parts merge_sort ( L1 , Sorted1 ) , merge_sort ( L2 , Sorted2 ) , % then each part is sorted merge") #$BaseKB)
(f "Defx:CMIL")
(a '(#$comment #$Defx:CMIL "consists of libraries of domain theories , ontologies and component device models ; a CMIL editor and browser for assembling , extending , and customizing the libraries ; a model composer that composes a mathematical model of a physical system from the domain theory and a scenario ( the scenario defines the relations among the physical components , initial conditions , stopping conditions , etc . )") #$BaseKB)
(f "Defx:CompositionalModeling")
(a '(#$comment #$Defx:CompositionalModeling "permit models to be composed from reusable modules") #$BaseKB)
(f "Defx:DomainTheories")
(a '(#$comment #$Defx:DomainTheories "models of behavior of physical systems") #$BaseKB)
(f "Defx:Human-KBInteraction")
(a '(#$comment #$Defx:Human-KBInteraction "propose to build tools to aid in understanding the contents of a KB and tools to test adequacy , coverage , and correctness of KBs") #$BaseKB)
(f "Defx:KnowledgeFormation")
(a '(#$comment #$Defx:KnowledgeFormation ") structural comparisons of objects and knowledge bases to support identification of analogous objects or scenarios") #$BaseKB)
(f "Defx:KnowledgeFormation")
(a '(#$comment #$Defx:KnowledgeFormation "propose to build structural comparisons to report similarities and differences among objects or KBs ; diagnosis tools to detect incomplete or inconsistent knowledge ; and a markup language for annotation of what knowledge to present and use in reasoning") #$BaseKB)
(f "Defx:Ontolingua")
(a '(#$comment #$Defx:Ontolingua "provides object - oriented extensions to KIF , is the underlying object browsing , ontology editing , versioning , and logging system for our work") #$BaseKB)
(a '(#$comment #$Defx:Ontolingua "supports not only the development of ontologies by individuals , but also the process of achieving consensus on common ontologies by distributed groups") #$BaseKB)
(f "Defx:OntolinguaOntologyDevelopmentEnvironment")
(a '(#$comment #$Defx:OntolinguaOntologyDevelopmentEnvironment "provides a suite of effective easy - to - use tools for creating , accessing , using , and maintaining reusable ontologies") #$BaseKB)
(f "Defx:TheoryManipulation")
(a '(#$comment #$Defx:TheoryManipulation "To rapidly integrate the KBs of many groups") #$BaseKB)
(f "Defx:ExitCriteria")
(a '(#$comment #$Defx:ExitCriteria "deployed structural comparison module that is available to the RKF community for use on MELD KBs") #$BaseKB)
(f "Defx:HighPerformanceKnowledge-BasedProcessing")
(a '(#$comment #$Defx:HighPerformanceKnowledge-BasedProcessing "issues concerning performance versus size of knowledge bases ( KBs )") #$BaseKB)
(f "Defx:ConceptualOntologies")
(a '(#$comment #$Defx:ConceptualOntologies "structured real - world information into computer - understandable data") #$BaseKB)
(f "Defx:ModusTollens")
(a '(#$comment #$Defx:ModusTollens "asserting the contrapositive as a result of transitioning through the normal forms") #$BaseKB)
(f "Defx:SubsumptiveHeuristics")
(a '(#$comment #$Defx:SubsumptiveHeuristics "Checking on more general cases before attempting to do a long and expensive backchain path") #$BaseKB)
(f "Defx:TOLENSPONENS")
(a '(#$comment #$Defx:TOLENSPONENS "database of everything we found undisputable in the world database of everything that was absolutely impossible") #$BaseKB)
(f "Defx:KbLogic")
(a '(#$comment #$Defx:KbLogic "knowledge base s needed special attention that normal logics didn t account for") #$BaseKB)
(f "Defx:AbstractEpisodicMemory")
(a '(#$comment #$Defx:AbstractEpisodicMemory "past - oriented memory system that allows reexperiencing previous events") #$BaseKB)
(f "Defx:Amnesia")
(a '(#$comment #$Defx:Amnesia "condition in which a person fails to recollect episodic memory") #$BaseKB)
(f "Defx:ClassicalConditioning")
(a '(#$comment #$Defx:ClassicalConditioning "type of associative learning in which an arbitrary stimulus is associated with a reward or punishment") #$BaseKB)
(f "Defx:CognitionAndProblemSolvingCognition")
(a '(#$comment #$Defx:CognitionAndProblemSolvingCognition "process of knowing that may include awareness , reasoning , recollection , and judgment") #$BaseKB)
(f "Defx:EpisodicMemory")
(a '(#$comment #$Defx:EpisodicMemory "neurocognitive system that renders possible the conscious recollection of events as they were previously experienced") #$BaseKB)
(a '(#$comment #$Defx:EpisodicMemory "concerned with personal experiences ( hence also called autobiographical") #$BaseKB)
(a '(#$comment #$Defx:EpisodicMemory "information that is linked to a particular place and time") #$BaseKB)
(a '(#$comment #$Defx:EpisodicMemory "composed of a number of distinct but interacting component processes") #$BaseKB)
(f "Defx:Habituation")
(a '(#$comment #$Defx:Habituation "repeated exposure to a stimulus decreases an organism 's responsiveness to the stimulus") #$BaseKB)
(f "Defx:HebbianHypothesis")
(a '(#$comment #$Defx:HebbianHypothesis "proposes that sensorimotor experience plays a facilitative role , and that its effects are mediated by learning that is sensitive only to contiguity") #$BaseKB)
(f "Defx:IntegrationExperiments")
(a '(#$comment #$Defx:IntegrationExperiments "Original experiments ( factor combination") #$BaseKB)
(f "Defx:KorsakoffSPsychosis")
(a '(#$comment #$Defx:KorsakoffSPsychosis "occurs in some persons with chronic alcoholism ( with vitamin B1 deficiency ) , rendering them unable to store episodic memory the person can remember all past memories but new memories are not recorded") #$BaseKB)
(f "Defx:OperantConditioning")
(a '(#$comment #$Defx:OperantConditioning "type of associative learning in which an animal learns to associate one of its behaviors with a reward or punishment") #$BaseKB)
(f "Defx:ProblemSolving")
(a '(#$comment #$Defx:ProblemSolving "process of devising a strategy to overcome an obstacle") #$BaseKB)
(f "Defx:SemanticMemory")
(a '(#$comment #$Defx:SemanticMemory "general knowledge that is not linked to a particular temporal or spatial context") #$BaseKB)
(f "Defx:TI")
(a '(#$comment #$Defx:TI "ability to deduce that if Item B is related to Item C and Item C is related to Item D , then Item B must be related to Item D.") #$BaseKB)
(f "Defx:Tanzsprache")
(a '(#$comment #$Defx:Tanzsprache "information about direction , distance , and quality of a resource ( such as food or nesting sites ) contained within the waggle dance") #$BaseKB)
(f "Defx:TransitiveInference")
(a '(#$comment #$Defx:TransitiveInference "form of deductive reasoning that allows one to derive a relation between items that have not been explicitly compared before") #$BaseKB)
(f "Defx:WaggleDance")
(a '(#$comment #$Defx:WaggleDance "term used in beekeeping and ethology for a particular figure - eight dance of the honey bee") #$BaseKB)
(f "Defx:Arrival-RatioForASpecificStation")
(a '(#$comment #$Defx:Arrival-RatioForASpecificStation "ratio of the number of new - arrivals at that specific station for a particular distribution of new - arrivals , to the total number of new - arrivals for that particular distribution") #$BaseKB)
(f "Defx:AssociativeLearning")
(a '(#$comment #$Defx:AssociativeLearning "animals associate one feature of their environment with another") #$BaseKB)
(f "Defx:AssociativeSequenceLearning")
(a '(#$comment #$Defx:AssociativeSequenceLearning "suggests that sensorimotor experience plays an inductive role in the development of the mirror neuron system , and that it can play this crucial role because its effects are mediated by learning that is sensitive to both contingency and contiguity") #$BaseKB)
(f "Defx:AutobiographicalMemory")
(a '(#$comment #$Defx:AutobiographicalMemory "memory for and about a person 's own life") #$BaseKB)
(f "Defx:Autonoetic")
(a '(#$comment #$Defx:Autonoetic "capable of roaming at will in subjective time , by recollecting aspects of past experiences , or imagining possible future experiences") #$BaseKB)
(f "Defx:BlackDwarfHoneybee")
(a '(#$comment #$Defx:BlackDwarfHoneybee "nests hang from twigs or branches") #$BaseKB)
(f "Defx:ClassicalConditioning")
(a '(#$comment #$Defx:ClassicalConditioning "animal receives no benefit from associating the CS with the UCS") #$BaseKB)
(f "Defx:CognitiveMap")
(a '(#$comment #$Defx:CognitiveMap "internal representation of spatial relationships between objects in an animal s surroundings often using particular landmarks") #$BaseKB)
(f "Defx:CulturalInheritance")
(a '(#$comment #$Defx:CulturalInheritance "one or more members of the population learn a novel behavior and that behavior spreads through the population by imitation") #$BaseKB)
(f "Defx:GreatTits")
(a '(#$comment #$Defx:GreatTits "species of birds found in England") #$BaseKB)
(f "Defx:LanguageHypothesis")
(a '(#$comment #$Defx:LanguageHypothesis "apart from attributing to honey bees a human - level language , also attributes to them a search for odor within a confined range ( either as an initial step , when the dance is a round dance , or as a final step after use of language , when the dance is a figure eight dance ) , and a return to the hive if the odor is not found within the confined range") #$BaseKB)
(f "Defx:OlfactoryHypothesis")
(a '(#$comment #$Defx:OlfactoryHypothesis "views arrival of recruits as a probability matter") #$BaseKB)
(f "Defx:OperantConditioning")
(a '(#$comment #$Defx:OperantConditioning "unassociated behavior becomes associated with a reward") #$BaseKB)
(f "Defx:Recruiting-Efficiency")
(a '(#$comment #$Defx:Recruiting-Efficiency "number of new - arrivals per dance") #$BaseKB)
(f "Defx:SemanticMemory")
(a '(#$comment #$Defx:SemanticMemory "neurocognitive system that makes possible the acquisition , retention , and use of factual information whose retrieval is accompanied by noetic awareness") #$BaseKB)
(f "Defx:Signifier")
(a '(#$comment #$Defx:Signifier "physical or phonetic representation of a sign") #$BaseKB)
(f "Defx:TransitionalRoundDanceDancesWaggleDance")
(a '(#$comment #$Defx:TransitionalRoundDanceDancesWaggleDance "performed when the resource is at a distance of 20 to 30 metres away from the hive , and finally , when it is located at distances greater than 40 metres from the hive") #$BaseKB)
(f "Defx:WaggleDance")
(a '(#$comment #$Defx:WaggleDance "direction the bee moves in relation to the hive indicates direction ; if it moves vertically the direction to the source is directly towards the Sun") #$BaseKB)
(a '(#$comment #$Defx:WaggleDance "consists of one to 100 or more circuits , each of which consists of two phases : the waggle phase and the return phase") #$BaseKB)
;; (f "Defx:WorkerBee'sWaggleDance")
;; (a '(#$comment #$Defx:WorkerBee'sWaggleDance "involves running through a small figure - eight pattern : a waggle run ( aka waggle phase ) followed by a turn to the right to circle back to the starting point ( aka return phase ) , another waggle run , followed by a turn and circle to the left , and so on in a regular alternation between right and left turns after waggle runs") #$BaseKB)
(f "Defx:CBL")
(a '(#$comment #$Defx:CBL "wrote new software in C based on specifications of what you needed the program to do") #$BaseKB)
(f "Defx:WeakAI")
(a '(#$comment #$Defx:WeakAI "problems that are solved by existing mathematical and computational technologies - that is , all problems that are computable by classical computers") #$BaseKB)
(f "Defx:NegativePunishment")
(a '(#$comment #$Defx:NegativePunishment "taking away something pleasant after a behavior occurs") #$BaseKB)
(f "Defx:NegativeReinforcement")
(a '(#$comment #$Defx:NegativeReinforcement "involves the removal of an unpleasant stimulus , like telling a child that if she eats all her potatoes then she won t have to eat her broccoli") #$BaseKB)
(f "Defx:PositivePunishment")
(a '(#$comment #$Defx:PositivePunishment "applying an unpleasant event after a behavior") #$BaseKB)
(f "Defx:PositiveReinforcement")
(a '(#$comment #$Defx:PositiveReinforcement "involves presenting a favorable outcome , such as giving a child a treat after she cleans her room") #$BaseKB)
;; (f "Defx:Axiom(5")
;; (a '(#$comment #$Defx:Axiom(5 "states that no individual is its own child") #$BaseKB)
(f "Defx:CommonLogic")
(a '(#$comment #$Defx:CommonLogic "framework for a family of logic - based languages") #$BaseKB)
(f "Defx:HITIQA")
(a '(#$comment #$Defx:HITIQA "QA system that retrieves documents from a corpus based on an interactive question - and - answer dialogue with users") #$BaseKB)
(f "Defx:InformationSharing")
(a '(#$comment #$Defx:InformationSharing "references the capability to take information expressed in the language of one ontology , and re - express it in the language of another") #$BaseKB)
(f "Defx:JointReasoning")
(a '(#$comment #$Defx:JointReasoning "references the capability to reason over the knowledge contained in a number of systems while preserving semantic consequences between systems") #$BaseKB)
(f "Defx:Provability-BasedSemanticInteroperability")
(a '(#$comment #$Defx:Provability-BasedSemanticInteroperability "logic - based approach to information sharing and joint reasoning among knowledge - driven systems that employ disparate representation schemes") #$BaseKB)
(f "Defx:SchemaMatchings")
(a '(#$comment #$Defx:SchemaMatchings "one - to - one between vocabulary terms") #$BaseKB)
(f "Defx:TradecraftPrimer")
(a '(#$comment #$Defx:TradecraftPrimer "Structured Analytic Techniques for Improving Intelligence Analysis") #$BaseKB)
(f "Defx:UAVCapabilitiesOntology")
(a '(#$comment #$Defx:UAVCapabilitiesOntology "used to indicate that the UAV is capable of destroying building") #$BaseKB)
(f "Defx:Justifications")
(a '(#$comment #$Defx:Justifications "formal proofs and models within many - sorted logic") #$BaseKB)
(f "Defx:Multi-SystemTests")
(a '(#$comment #$Defx:Multi-SystemTests "designed to imitate the flow of information between specialized analysts working collaboratively on a task , yet using different analytical software") #$BaseKB)
(f "Defx:OntologyTranslations")
(a '(#$comment #$Defx:OntologyTranslations "knowing what types of information can be translated from source ontology to target ontology , and what types of information can not be translated") #$BaseKB)
(f "Defx:Provability-BasedQuery")
(a '(#$comment #$Defx:Provability-BasedQuery "query whose yes / no response must be accompanied by an explicit justification") #$BaseKB)
(f "Defx:Provability-BasedSemanticInteroperability")
(a '(#$comment #$Defx:Provability-BasedSemanticInteroperability "framework transcending syntactic translation that enables robust , meaningful , knowledge exchange across diverse information systems") #$BaseKB)
(f "Defx:Query")
(a '(#$comment #$Defx:Query "yes / no question posed to a set of knowledge - driven systems that have been interrelated by some interoperability approach ( e.g. , schema matchings , schema morphisms , and translation graphs )") #$BaseKB)
(f "Defx:SchemaMorphism")
(a '(#$comment #$Defx:SchemaMorphism "maps a subset of expressions ( as opposed to simply vocabulary terms ) drawn from one ontology into expressions of another") #$BaseKB)
(f "Defx:SemanticSyntacticInteroperabilityInteroperability")
(a '(#$comment #$Defx:SemanticSyntacticInteroperabilityInteroperability "requires not only shared protocols for communication and information exchange understanding , and consequences , of information are preserved faithfully across systems") #$BaseKB)
(f "Defx:TranslationGraph")
(a '(#$comment #$Defx:TranslationGraph "visual trace of the incremental construction and interrelation of ontology signatures") #$BaseKB)
(a '(#$comment #$Defx:TranslationGraph "directed graph whose vertices are signatures , and whose edges are relationships between signatures") #$BaseKB)
(f "Defx:Conversation_Manager_UI")
(a '(#$comment #$Defx:Conversation_Manager_UI "conversational management system being put together by Amirouche ( arew ) It makes it easier to debug / present :") #$BaseKB)
(f "Defx:DarwinianTheory")
(a '(#$comment #$Defx:DarwinianTheory "any component that doesn t offer an advantage to an organism ( i.e. , doesn t function ) will be lost or discarded") #$BaseKB)
(f "Defx:Anthromorphisms")
(a '(#$comment #$Defx:Anthromorphisms "Certain") #$BaseKB)
(f "Defx:BacterialFlagella")
(a '(#$comment #$Defx:BacterialFlagella "most efficient machine in the universe with its self assembly and repair , water - cooled rotary engine , proton motive - force drive system , forward and reverse gears , operating speeds of 6 , 000 to 17 , 000 rpm , direction - reversing capability , and hard - wired signal - transduction system with short - term memory") #$BaseKB)
(f "Defx:Flagellum")
(a '(#$comment #$Defx:Flagellum "corkscrew - shaped , hair - like appendage attached to the cell surface acting like a propeller , allowing the bacterium to swim") #$BaseKB)
(a '(#$comment #$Defx:Flagellum "contains a rod ( drive shaft ) , a hook ( universal joint ) , L- and P - rings ( bushings / bearings ) , S- and M - rings ( rotor ) , and a C - ring and stud ( stator )") #$BaseKB)
(f "Defx:IrreduciblyComplexSystem")
(a '(#$comment #$Defx:IrreduciblyComplexSystem "one that requires several interlacing parts to be present at the same time , where the removal of one or more parts causes the whole system to malfunction") #$BaseKB)
(f "Defx:NarrativelyIntelligentMentalModel")
(a '(#$comment #$Defx:NarrativelyIntelligentMentalModel "One that manipulates protolanguage") #$BaseKB)
(f "Defx:Protolanguage")
(a '(#$comment #$Defx:Protolanguage "hypothetical undocumented parent language from which actual acts such as behaviours and signalling are derived") #$BaseKB)
(a '(#$comment #$Defx:Protolanguage "makes") #$BaseKB)
(f "Defx:CentralDictionary")
(a '(#$comment #$Defx:CentralDictionary "defines everything used in the program other than code : data items , configuration options , security") #$BaseKB)
(f "Defx:Configuration")
(a '(#$comment #$Defx:Configuration "every part of the application that is configurable should be configured as part of the programming language environment , not by custom application code") #$BaseKB)
(f "Defx:HelpText")
(a '(#$comment #$Defx:HelpText "tool so a developer can click on a feature ( like a window ) , and it opens up an editor to write help text for that feature") #$BaseKB)
(f "Defx:Security")
(a '(#$comment #$Defx:Security "enabling / disabling features based on security points") #$BaseKB)
(f "Defx:TrackReliability")
(a '(#$comment #$Defx:TrackReliability "more reliable data beats less reliable data") #$BaseKB)
(f "Defx:IPeopleDataMtDenotationRelatedToQueryTemplateRelnMtContextOfPCWFnXtQuestionTemplateLoves")
(a '(#$comment #$Defx:IPeopleDataMtDenotationRelatedToQueryTemplateRelnMtContextOfPCWFnXtQuestionTemplateLoves "Mt loves xRelationalNCRuleFn denotationRelatedTo denotationRelatedTo xRelationalNCRuleFnInstanceLevel tSetOfRequireOneFn tSetOfNLPatternWordFn tSetOfNLPatternWordFn conceptuallyRelated vtLove loves ) Mt : ( mtDocumentReaderFollowupsForTaskMtFn iCW_GeneralCycKETaskAllotment ) throughout 2004 - 12 - 20 ( generateFormulasWithTermForInstances ( mobGraduateFn tGroupedUniversity ) loves ) Mt : iGKEFormulaTemplatesMt ( inducedTemplateForBinaryPredicate iInducedFactEntryTemplateForUniversityGraduates_87 loves xDoTheWord xtDoAux xLoveTheWord xtVerb ` ` who '' ` ` what '' ) ( tSetOfOptionalOneFn ( tSetOfNLPatternWordFn xDoTheWord xtDoAux ) ) ( tSetOfNLPatternWordFn xLoveTheWord xtVerb ) ( xNLPatternTemplateFn xtNPTemplate : ARG2 ) loves 2 xLoveTheWord ) loves xInLoveMWW xtAdjectiveGradable 0 loves ) Mt : iGeneralEnglishMt ( denotationRelatedTo xBelovedTheWord xtAdjectiveGradable 0 loves xLoveTheWord xtVerb 0 loves loves 2 ( xWordWithSuffixFn xLoveTheWord xEr_ConcreteNounProducingTheSuffix ) ) ( xRelationalNCRuleFn loves 2 ( xWordWithSuffixFn xLoveTheWord xEr_AgentTheSuffix ) ) ( xRelationalNCRuleFn loves 2 xLoveTheWord ) ( xRelationalNCRuleFnInstanceLevel loves 2 ( xWordWithSuffixFn xLoveTheWord xEr_ConcreteNounProducingTheSuffix ) ) ( xRelationalNCRuleFnInstanceLevel loves 2 ( xWordWithSuffixFn xLoveTheWord xEr_AgentTheSuffix ) iBillClinton iChelseaClinton : iAuthorsMt Direction : Backward ( implies ( and ( isa ? PHILOSOPHER mobPhilosopher ) ( loves ? SWINGER ? PHILOSOPHER ) ( usesObject ? PHILOSOPHER ? SWINGER ) ( isa ? SWINGER mobSwinger ) ) ( loves ? PHILOSOPHER ? SWINGER ) ) Mt : iGuysTestMt Direction : Forward") #$BaseKB)
(f "Defx:IReligiousPeopleDataMt")
(a '(#$comment #$Defx:IReligiousPeopleDataMt "conceptuallyRelated Mt loves ? X ? Y ) : iFACToryVerifiedSentenceMt ( actionTypeExpressesFeelingType actCuddling vtLove ) ( actionTypeExpressesFeelingType actHugging vtLove ) Mt : iHumanActivitiesMt ( actionTypeExpressesFeelingType actCuddling vtLove ) iValentineTheMartyr vtLove ) Mt : iShoppingGMt ( conceptuallyRelated tObjectLoveBirthdayCard vtLove )") #$BaseKB)
(f "Defx:ITourAndVacationPackageItinerariesMt")
(a '(#$comment #$Defx:ITourAndVacationPackageItinerariesMt "backchainForbidden loves") #$BaseKB)
;; (f "Defx:SentenceParameterValueInSpecificationSentenceParameterValueInSpecificationChildrenSentenceParameterValueInSpecificationSentenceParameterValueInSpecificationSentenceParameterValueInSpecificationBackwardVPositiveAmountFnVtLove?PARENT?CHILD")
;; (a '(#$comment #$Defx:SentenceParameterValueInSpecificationSentenceParameterValueInSpecificationChildrenSentenceParameterValueInSpecificationSentenceParameterValueInSpecificationSentenceParameterValueInSpecificationBackwardVPositiveAmountFnVtLove?PARENT?CHILD "xQuoteFn loves sentenceParameterValueInSpecification implies tSetOfTheSetFn implies isa ? SWINGER mobSwinger ) ) ( loves ? PHILOSOPHER ? SWINGER ) ) Mt : iGuysTestMt Direction : Forward ( implies ( and ( loves ? X ? X ) ( isa ? X tClazzCamel ) ) ( loves ? X iGroup_CityOfAustinTX ) ) Mt : iHumanActivitiesMt Direction : Backward ( implies ( and ( isa ? L mobSentientAnimal ) ( isa ? P tClazzDomesticPet ) ( owns ? L ? P ) ) ( loves ? L ? P ) ) ( implies ( and ( isa ? PARENT mobPerson ) ( children ? PARENT ? CHILD ) ( likesAsFriend ? PARENT ? CHILD ) ) ( loves ? PARENT ? CHILD ) ( and ( isa ? COUPLE tGroupedCoupleRomantic ) ( groupMembers ? COUPLE ? PERSON1 ) ( groupMembers ? COUPLE ? PERSON2 ) ( different ? PERSON1 ? PERSON2 ) ) ( loves ? PERSON1 ? PERSON2 ) ) ( implies ( and ( isa ? PERSON1 mobPerson ) ( cohabitingFamilyMembers ? PERSON1 ? PERSON2 ) ) ( loves ? PERSON1 ? PERSON2 ) ) Miscellaneous References : ( ncRuleTemplate ( xRelationalNCRuleFnInstanceLevel loves 2 xLoveTheWord ) ( loves ) ) in ( mtMtSpaceFn ( mtDocumentReaderFollowupsForTaskMtFn iCW_GeneralCycKETaskAllotment ) ( mtMtTimeWithGranularityDimFn ( iTimeOf_DateFromStringFn ` ` 2004 - 12 - 20 '' ) timeOfTimePoint ) ) ( sentenceParameterValueInSpecification ( xQuoteFn ( goals iPrincess_001 ( loves iKermitTheFrog iPrincess_001 ) ) ) ( iCW_TestQueryFn iCW_CSTIsGoalOfPrincessToBeLovedByKermit ) ) ( and ( isa ? PARENT mobPerson ) ( children ? PARENT ? CHILD ) ( cohabitants ? PARENT ? CHILD ) ) ( loves ? PARENT ? CHILD ) ) ( xQuoteFn ( implies ( and ( isa ? PARENT mobPerson ) ( children ? PARENT ? CHILD ) ) ( loves ? PARENT ? CHILD ) ) ) ? PARENT ? CHILD ) ) ) ( iCW_TestQueryFn iCST_DoParentsLoveTheirChildren_2 ) ) ( implies ( and ( isa ? PARENT mobPerson ) ( children ? PARENT ? CHILD ) ( likesAsFriend ? PARENT ? CHILD ) ) ( loves ? PARENT ? CHILD ) ) ) ( iCW_TestQueryFn iCST_QSO_DoParentsLoveTheirChildren_2 ) )") #$BaseKB)
(f "Defx:IMMEDIATE-RELATIONNamespace")
(a '(#$comment #$Defx:IMMEDIATE-RELATIONNamespace "MEDIATED Entity used in classes : Abstract - Quality Physical - Quality Quality Temporal - Quality used in properties : HAS - QUALITY property LOCATION namespace - RELATION domain : Entity range : Entity used in properties : DEPENDS - ON GENERIC - LOCATION HAPPENS - AT MEDIATED - RELATION OVERLAPS PRESENT - AT PROPER - PART Q - PRESENT - AT SIBLING - PART property MEMBER - OF namespace : relation btw an instance of a concept and the name ( instance of a concrete data type ) of that concept") #$BaseKB)
(f "Defx:InstrumentalityAbstract-QualityNamespaceClassAtomNamespace")
(a '(#$comment #$Defx:InstrumentalityAbstract-QualityNamespaceClassAtomNamespace "primitive Phenomenon defined used primitive TEMPORARY - COMPONENT - OF TEMPORARY - PART TEMPORARY - PART - OF TEMPORARY - PROPER - PART TEMPORARY - PROPER - PART - OF TEMPORARY - TOTAL - PARTICIPANT TEMPORARY - TOTAL - PARTICIPANT - IN TIME - OF - HAPPENING - OF TIME - OF - PRESENCE - OF TIME - OF - Q - PRESENCE - OF TOTAL - PARTICIPANT TOTAL - PARTICIPANT - IN Individuals class Abstract namespace superclasses : Event class Activity namespace : in classes : Social - Agent Society axioms : disjoint Agentive - Social - Object Non - Agentive - Social - Object class Amount - Of - Matter namespace : http : //ontology.ip.rm.cnr.it / ontologies / DOLCE - Lite # type : primitive superclasses : Physical - Endurant axioms : disjoint Amount - Of - Matter Feature disjoint Amount - Of - Matter Physical - Object class Arbitrary - Sum namespace : superclasses : Entity constraints : restriction PROPER - PART to - class ( not Entity ) known subclasses : Temporary - Atom used in classes : Temporary - Atom axioms : covered Atom by ( restriction ATOMIC - PART - OF to - class Entity ) class Biological - Object namespace : http : //ontology.ip.rm.cnr.it constraints : restriction PARTICIPANT has - class Biological - Object class Color - Quality namespace : http : //ontology.ip.rm.cnr.it / ontologies / DOLCE - Lite # type : primitive superclasses : Physical - Quality class Commerce namespace : http : //ontology.ip.rm.cnr.it / ontologies / DOLCE - Lite # type : primitive superclasses : Transaction class Construction namespace : http : //ontology.ip.rm.cnr.it / ontologies / DOLCE - Lite # type : primitive superclasses : Artifact class Conveyance namespace : http : //ontology.ip.rm.cnr.it / ontologies / DOLCE - Lite # type : primitive superclasses : Instrumentality known subclasses : Vehicle used in classes : Vehicle class Country namespace : superclasses : Political - Geographic - Object class Date namespace : http : //ontology.ip.rm.cnr.it / ontologies / DOLCE - Lite # type : primitive superclasses : Time - Interval class Dependent - Place namespace : http : //ontology.ip.rm.cnr.it / ontologies / DOLCE - Lite # type : primitive superclasses : Feature class Device namespace : http : //ontology.ip.rm.cnr.it / ontologies / DOLCE - Lite # type : primitive superclasses : Instrumentality class Economic - Process namespace : http : //ontology.ip.rm.cnr.it / ontologies / DOLCE - Lite # type : primitive superclasses : Phenomenon class Endurant namespace") #$BaseKB)
(f "Defx:Identifier")
(a '(#$comment #$Defx:Identifier "concrete data type , usually non - meaningful from the lexical viewpoint") #$BaseKB)
(f "Defx:Collaboration")
(a '(#$comment #$Defx:Collaboration "to discuss a plan and to follow a plan") #$BaseKB)
(f "Defx:SolutionUnderstanding")
(a '(#$comment #$Defx:SolutionUnderstanding "theoretical ability to answer all relevant questions") #$BaseKB)
(f "Defx:Tau")
(a '(#$comment #$Defx:Tau "network representing networking languages") #$BaseKB)
(f "Defx:EmergentaNaturals")
(a '(#$comment #$Defx:EmergentaNaturals "spontaneously occurred and changing in Humanity - the collective , the reactor and the product of human collaboration") #$BaseKB)
(f "Defx:Program")
(a '(#$comment #$Defx:Program "set of coded instructions that a computer can understand to solve a problem or produce a desired result") #$BaseKB)
(f "Defx:TotalDecentralization")
(a '(#$comment #$Defx:TotalDecentralization "choice and decentralization are two different things , no one can guarantee that all choices can be decentralized") #$BaseKB)
;; (f "Defx:DefineDefineDefineObPerson$Create-Initial-Fact-Initial-Fact-Initial-Fact")
;; (a '(#$comment #$Defx:DefineDefineDefineObPerson$Create-Initial-Fact-Initial-Fact-Initial-Fact "FEMALE ROMANTIC MALE if ` ` person M - PURCHASE object from store '' then ` ` person has POS - ATTITUDE toward object '' - PERSON ` ` Jerry '' obname Jerry - INTEREST Jerry ) - PERSON obname Jerry - Gf )") #$BaseKB)
(f "Defx:GUE_NonVisibleStateGUElementState")
(a '(#$comment #$Defx:GUE_NonVisibleStateGUElementState "has any any window other than the active one on a screen is passive : ( = > ( and ( instance ? WINDOW_A InterfaceWindow & % GUIElement that is part of a passive & % GUIElement ( including an ; & % InterfaceWindow ) is also passive : ( = > ( and ( instance ? GUIE_SM GUIElement ) ( instance ? GUIE_BIG GUIElement a & % GUE_NonVisibleState if it conceptually exists , but does not appear on a & % ComputerScreen . '' ) ; any & % GUIElement that is part of a non - visible & % GUIElement ( including an ; & % InterfaceWindow non - visible window may not be active : ( not ( and ( hasGUEState ? WINDOW GUE_NonVisibleState ) ( hasGUEState ? WINDOW GUE_ActiveState") #$BaseKB)
(f "Defx:GUIE_BIGGUIElement")
(a '(#$comment #$Defx:GUIE_BIGGUIElement "if any & % GUIElement that is part of a covered & % GUIElement two different non - window & % GUIElements are active on the same screen , ; one is a part of the other ; E.g. , a menu & menuitem or submenu : ( = > ( and ( instance ? GUIE1 GUIElement ) ( instance ? GUIE2 GUIElement") #$BaseKB)
(f "Defx:VoiceXML")
(a '(#$comment #$Defx:VoiceXML "programming language specifically designed to do complex menuing") #$BaseKB)
(f "Defx:ContraryAttributeGUE_MinimizedStateGUE_ActiveState")
(a '(#$comment #$Defx:ContraryAttributeGUE_MinimizedStateGUE_ActiveState "has although any & % GUIElement that is part of an offscreen & % GUIElement ( including an ; & % InterfaceWindow it might have an assigned position on the screen , it does not appear on the screen and is can not be made active until it is reopened a & % MaximizedWindowState if it is sized to cover the whole screen and is not minimized") #$BaseKB)
(f "Defx:BlackboardSystems")
(a '(#$comment #$Defx:BlackboardSystems "Blackboard Model of Problem Solving and the Evolution of Blackboard Architectures") #$BaseKB)
(f "Defx:Context-BasedVision")
(a '(#$comment #$Defx:Context-BasedVision "Recognising objects using both 2D and 3D imagery ' '") #$BaseKB)
(f "Defx:GPS")
(a '(#$comment #$Defx:GPS "program that simulates human thought") #$BaseKB)
(f "Defx:OutOfContext")
(a '(#$comment #$Defx:OutOfContext "Computer systems that adapt to , and learn from , context") #$BaseKB)
(f "Defx:ResourceBindingTrackingProblemTheoryManagement")
(a '(#$comment #$Defx:ResourceBindingTrackingProblemTheoryManagement "given set of constraints no more resource , replenish that resource ( if out of fuel , go get more") #$BaseKB)
(f "Defx:CharacterSourceFluent")
(a '(#$comment #$Defx:CharacterSourceFluent "variable that every time you REDO it moves to the next character in a file") #$BaseKB)
(a '(#$comment #$Defx:CharacterSourceFluent "variable that every time you REDO it moves to the next character in a file") #$BaseKB)
(f "Defx:Fluent")
(a '(#$comment #$Defx:Fluent "prolog variable that has coroutines attached ( and sometimes not )") #$BaseKB)
(a '(#$comment #$Defx:Fluent "prolog variable that has coroutines attached ( and sometimes not )") #$BaseKB)
(f "Defx:ARGUMENT")
(a '(#$comment #$Defx:ARGUMENT "abstract , not clearly delineated concept , is ` ` partially structured , understood , performed , and talked about in terms of WAR , '' which is a more concrete concept that emergesnaturally from the experience of physical combat") #$BaseKB)
(f "Defx:ARGUMENTSchema")
(a '(#$comment #$Defx:ARGUMENTSchema "derived systematically from the WARschema , represents an event in whichparticipants are adversaries embattled in a conflict of opinions ( not actual combat ) , whostruggle over positions , gain ground , win lose , and so on") #$BaseKB)
(f "Defx:Attributes")
(a '(#$comment #$Defx:Attributes "properties or qualities of objects , typically features of form , suchas color , shape , texture , or size , and features of function , such as use for sitting , for clothing , or for food") #$BaseKB)
(f "Defx:BUYER")
(a '(#$comment #$Defx:BUYER "person who possesses MONEY , the mediumof exchange , and SELLERis a person who possesses GOODS , the merchandise for sale") #$BaseKB)
(f "Defx:Bottom-UpProcessing")
(a '(#$comment #$Defx:Bottom-UpProcessing "processing initiated whendata are boundto variables in bottomlevel subschematathat moveupwardto activate the higher level schemata in which the subschemata are embedded") #$BaseKB)
(f "Defx:CohceptualDependency")
(a '(#$comment #$Defx:CohceptualDependency "theory of natural language understanding") #$BaseKB)
(f "Defx:DefaultValues")
(a '(#$comment #$Defx:DefaultValues "expectations or ` ` best guesses '' determined by the typical or normalvalues associated with variables") #$BaseKB)
(f "Defx:EXCHANGE")
(a '(#$comment #$Defx:EXCHANGE "interaction in which BUYER gives MONEY and gets GOODS , and SELLER gives GOODS and gets MONEY") #$BaseKB)
(f "Defx:FolkClassificationOfCeramics")
(a '(#$comment #$Defx:FolkClassificationOfCeramics "Study of Cognitive Prototypes") #$BaseKB)
(f "Defx:FrameAnalysis")
(a '(#$comment #$Defx:FrameAnalysis "Essay on the Organizationof Experience") #$BaseKB)
(f "Defx:LexicalMeaning")
(a '(#$comment #$Defx:LexicalMeaning "consists in a cognitive prototype to whichvarious real and imagined events maycorrespond in varying degrees ''") #$BaseKB)
(f "Defx:Ontologicalmetaphorsare")
(a '(#$comment #$Defx:Ontologicalmetaphorsare "used in comprehending events , actions , activities , and states") #$BaseKB)
(f "Defx:OrientationSchemata")
(a '(#$comment #$Defx:OrientationSchemata "represent knowledgeabout spatial relations amongobjects and their relative positions in the physical environment ; they alwaysinclude a representation of the self because ` ` Egoand world are perceptually inseparable ''") #$BaseKB)
(f "Defx:OrientationalMetaphorsare")
(a '(#$comment #$Defx:OrientationalMetaphorsare "used to structure abstract concepts that are not well groundedin experiencein terms of concrete conceptsarising from experience with spatial relationships") #$BaseKB)
(f "Defx:PersonalScripts")
(a '(#$comment #$Defx:PersonalScripts "idiosyncratic sequencesof actions that single actors use to achieve personalgoals ( e.g. makinga date with a waitress in a restaurant") #$BaseKB)
(f "Defx:PrimitiveActs")
(a '(#$comment #$Defx:PrimitiveActs "predicates that specify active relationships in propositions") #$BaseKB)
(f "Defx:REASONINITIATIONcausationDISABLEENABLERESULTCausationCausationCausationCausation")
(a '(#$comment #$Defx:REASONINITIATIONcausationDISABLEENABLERESULTCausationCausationCausationCausation "state state state action RESULTS IN state change ENABLES action DISABLES action or act INITIATES mental state") #$BaseKB)
(f "Defx:SELLERBUYER")
(a '(#$comment #$Defx:SELLERBUYER "prototypically a person who owns GOODS , although less typically it may be a salesman or middleman ; and MONEY is prototypically cash , but it mayalso be a check , a charge card , or an I.O.U.") #$BaseKB)
(f "Defx:Schemata")
(a '(#$comment #$Defx:Schemata "knowledgestructures that are ` ` the building blocks of cognition , '' pervade theorizing about cognitive organization and function in cognitive science") #$BaseKB)
(f "Defx:StorySchemata")
(a '(#$comment #$Defx:StorySchemata "hierarchical structures in which processing is top - down") #$BaseKB)
(f "Defx:Taxonomies")
(a '(#$comment #$Defx:Taxonomies "occur widely in cultures and have been studied exten sively by anthropologists") #$BaseKB)
(f "Defx:ThesyntheticInformantmodelon")
(a '(#$comment #$Defx:ThesyntheticInformantmodelon "simulation of large lexical / semantic fields") #$BaseKB)
(f "Defx:Top-Downprocessing")
(a '(#$comment #$Defx:Top-Downprocessing "processing initiated when top level schemata activate embeddedsubschemata in the expectation that these subschematawill fit the data") #$BaseKB)
(f "Defx:UniversalSchemataare")
(a '(#$comment #$Defx:UniversalSchemataare "uniformin the human species because of innate faculties of the mindand / or inherent divisions in the natural word ; idiosyncratic schemataare unique to particular individuals as the result of their personal histories and life experiences") #$BaseKB)
(f "Defx:WARSchemaspecifies")
(a '(#$comment #$Defx:WARSchemaspecifies "event in which participants are adversaries whoattack and defend positions , plan strategies , maneuver , advance , retreat , counterattack , declare truces , surrender , and triumph") #$BaseKB)
(f "Defx:AttributeCategories")
(a '(#$comment #$Defx:AttributeCategories "biologically based categories of perceptual sensations that are ` ` general attributes of concrete things ''") #$BaseKB)
(f "Defx:ElaborateCausalChain")
(a '(#$comment #$Defx:ElaborateCausalChain "each action in the sequenceresults in conditions that enable the next action and must be completedbefore the next action can be started") #$BaseKB)
(f "Defx:EthnobiologiealTaxonomies")
(a '(#$comment #$Defx:EthnobiologiealTaxonomies "groupedinto mutually exclusive hierarchical ranks") #$BaseKB)
(f "Defx:Fingernail")
(a '(#$comment #$Defx:Fingernail "part of finger , finger and palmare parts of hand , handand forearmare parts of arm") #$BaseKB)
(f "Defx:InferenceTaxonomy")
(a '(#$comment #$Defx:InferenceTaxonomy "classification of mutually exclusive categories of inferences , including three major types of inferences and a numberof subtypes : logical inferences ( motivation , psychological cause , physical cause , and enablement ) , informational inferences ( pronominal , referential , spatiotemporal , worldframe , and elaborative ) , and value inferences ( evaluative )") #$BaseKB)
(f "Defx:JoggingshoeTennisShoe")
(a '(#$comment #$Defx:JoggingshoeTennisShoe "shoe used for jogging shoe used for playing tennis") #$BaseKB)
(f "Defx:KingdomrankCategory")
(a '(#$comment #$Defx:KingdomrankCategory "all - inclusive unique beginner ; it is the highest level category and delimits the entire domain") #$BaseKB)
(f "Defx:KnowledgeaboutInterrelationshipsAmongvariables")
(a '(#$comment #$Defx:KnowledgeaboutInterrelationshipsAmongvariables "more simple conditions requiring that the boundelement be a person , an object , or a subevent complexconditions requiring certain relations amongelements boundto sets of variables") #$BaseKB)
(f "Defx:LandmarksNodesDistrictsEdgesPaths")
(a '(#$comment #$Defx:LandmarksNodesDistrictsEdgesPaths "junctions where paths meet") #$BaseKB)
(f "Defx:Owner")
(a '(#$comment #$Defx:Owner "person who POSSESSES an object and a father is a person whois the male PARENT OFa child") #$BaseKB)
(f "Defx:PrototypicalLies")
(a '(#$comment #$Defx:PrototypicalLies "speechacts that are whollyabstract entities") #$BaseKB)
(f "Defx:SchemaTheory")
(a '(#$comment #$Defx:SchemaTheory "offers a broad , unified theoretical frameworkthat has the potential to integrate") #$BaseKB)
(f "Defx:Script")
(a '(#$comment #$Defx:Script "` ` predetermined , stereotyped sequence of actions that defines a well - known Annual Reviews") #$BaseKB)
(a '(#$comment #$Defx:Script "not a data structure that is available in one piece in memory , but rather a structure that is reconstructedfrom memory as it is needed to interpret experience") #$BaseKB)
(f "Defx:SettingSubschemaEpisodeSubschema")
(a '(#$comment #$Defx:SettingSubschemaEpisodeSubschema "comprised of an external event and the protagonist s reaction to it") #$BaseKB)
(f "Defx:StreetJunkies")
(a '(#$comment #$Defx:StreetJunkies "urban heroin addicts") #$BaseKB)
(f "Defx:StructuralMetaphors")
(a '(#$comment #$Defx:StructuralMetaphors "provide for the use of ` ` one highly structured and clearly delineated concept to structure another ''") #$BaseKB)
(f "Defx:TransferOfPossessionthat")
(a '(#$comment #$Defx:TransferOfPossessionthat "characterizes exchangesis represented by two temporally ordered subschemata that share the same set of variables but in different arrangements : one represents the earlier state in which the BUYERPOSSESSES the MONEYand the SELLER POSSESSES the GOODS , and the other represents the later state in which the BUYER POSSESSES the GOODS and the SELLER POSSESSES the MONEY") #$BaseKB)
(f "Defx:Vehicle")
(a '(#$comment #$Defx:Vehicle "any kind of object that can be used as transportation , and car , bus , and truck are categories of objects that function as vehicles") #$BaseKB)
(f "Defx:VersePattern")
(a '(#$comment #$Defx:VersePattern "beginningat the top of the hierarchy and movingdownthrough a series of included subcategories , then returning to the top and movingdownthrough another series of included subcategories") #$BaseKB)
(f "Defx:2APLSExecutionProcess")
(a '(#$comment #$Defx:2APLSExecutionProcess "relies on planning only one step ahead using the most up to date information of the belief base of the agent , and then executes the resulted action before returning to the next plan cycle") #$BaseKB)
(f "Defx:BeliefUpdates")
(a '(#$comment #$Defx:BeliefUpdates "actions used to handle with the current beliefs") #$BaseKB)
(f "Defx:BeliefsBase")
(a '(#$comment #$Defx:BeliefsBase "composed by Prolog facts and rules being handled as a Prolog program and the Goal base is composed only by ground atoms which are treated as a Prolog facts") #$BaseKB)
(f "Defx:Case-BasedPlanning")
(a '(#$comment #$Defx:Case-BasedPlanning "extract plans the expert seemed to follow in order to use them in future plays of a game") #$BaseKB)
(f "Defx:MUD")
(a '(#$comment #$Defx:MUD "multi - player computer game that combines elements of role - playing games and social chat rooms") #$BaseKB)
(f "Defx:PR-Rules")
(a '(#$comment #$Defx:PR-Rules "represent a set of exception rules which is used just when something goes wrong in the planning process") #$BaseKB)
(f "Defx:PlayME")
(a '(#$comment #$Defx:PlayME "consists on confronting the ME to play versus a human player or another ME , imitating the behaviours learned from the expert") #$BaseKB)
(f "Defx:Traces")
(a '(#$comment #$Defx:Traces "input data for the learning engine so it processes these traces and generates a data package which contains the knowledge inferred") #$BaseKB)
(f "Defx:Text-Driven")
(a '(#$comment #$Defx:Text-Driven "players read descriptions of rooms , objects , events , other characters , and computer - controlled creatures or non - player characters ( NPCs ) in a virtual world") #$BaseKB)
(f "Defx:AzitrexAzitrexMasterPieceMasterPieceMasterPiece")
(a '(#$comment #$Defx:AzitrexAzitrexMasterPieceMasterPieceMasterPiece "Read error : Connection reset by peer") #$BaseKB)
(f "Defx:MadarsMadars")
(a '(#$comment #$Defx:MadarsMadars "Ping timeout : 260 seconds") #$BaseKB)
(f "Defx:MasterPieceAzitrexAzitrex__")
(a '(#$comment #$Defx:MasterPieceAzitrexAzitrex__ "Read Ping timeout : 240 seconds error : Connection reset by peer") #$BaseKB)
;; (f "Defx:KIF/DamlLoadingSupport")
;; (a '(#$comment #$Defx:KIF/DamlLoadingSupport "Implemented Java RMI ( CVS ) for CoABS Girding as well as automatic agent programming from logical software rules") #$BaseKB)
(f "Defx:ArnoldLogoutAssertionEditor")
(a '(#$comment #$Defx:ArnoldLogoutAssertionEditor "Assert * relationship in terms of father and mother relationships : ( = > ( or ( exists ( ? F ) ( and ( father ? S1 ? F ) ( father ? S2 ? F ) ) ) ( exists ( ? M )") #$BaseKB)
(f "Defx:OntolinguaServer")
(a '(#$comment #$Defx:OntolinguaServer "Tool for Collaborative Ontology Construction") #$BaseKB)
(f "Defx:SCOOP")
(a '(#$comment #$Defx:SCOOP "assists developers in resolving conflicts and inconsistencies by identifying the statements by different developers that are problematic") #$BaseKB)
(f "Defx:SUMO")
(a '(#$comment #$Defx:SUMO "ontology that was created at Teknowledge Corporation with extensive input from the SUO mailing list , and it has been proposed as a starter document for the IEEEsanctioned SUO Working Group") #$BaseKB)
(f "Defx:SigmaOntologyWorkbench")
(a '(#$comment #$Defx:SigmaOntologyWorkbench "Web aplication that allows a user to load and browse one or more ontology files , export to different formats , query the combined Knowledge Base , and perform certain types of checking") #$BaseKB)
(f "Defx:SystemForCollaborativeOpenOntologyProduction")
(a '(#$comment #$Defx:SystemForCollaborativeOpenOntologyProduction "manipulates logic expressions and checks for redundancies or contradictions between the products developed by different engineers") #$BaseKB)
(a '(#$comment #$Defx:SystemForCollaborativeOpenOntologyProduction "works with logic expressions ( among other knowledge products ) , which can be understood , to some degree , by a machine") #$BaseKB)
(f "Defx:Determiner-Central")
(a '(#$comment #$Defx:Determiner-Central "Determiner - ClassA ' , ' Determiner - ClassB ' , ' Determiner - ClassC ' , ' ExpletivePronoun ' , ' IndefinitePronoun ' , ' Number - SP ' , ' ObjectPronoun ' , ' PossessivePronoun ' , ' PossessivePronoun - Post ' , ' Postdeterminer ' , ' Pronoun ' , ' Pronoun - SubjectOrObject ' , ' ReciprocalPronoun ' , ' ReflexivePronoun ' , ' SubjectPronoun ' , ' WHDeterminer ' , ' WHPronoun ' ] ] [ [ txt , costumes ] , [ tag , z , nns , ' CountNoun '") #$BaseKB)
(f "Defx:HIM")
(a '(#$comment #$Defx:HIM "PronounFn ThirdPerson - NLAttr Singular - NLAttr Masculine - NLAttr ObjectPronoun") #$BaseKB)
(a '(#$comment #$Defx:HIM "PronounFn ThirdPerson - NLAttr Singular - NLAttr Masculine - NLAttr ObjectPronoun") #$BaseKB)
(a '(#$comment #$Defx:HIM "PronounFn ThirdPerson - NLAttr Singular - NLAttr Masculine - NLAttr ObjectPronoun") #$BaseKB)
(f "Defx:PossessivePronoun-Post")
(a '(#$comment #$Defx:PossessivePronoun-Post "tag , staart , prp , ppss , ' Determiner ' , ' Determiner - Central ' , ' Determiner - ClassA ' , ' Determiner - ClassB ' , ' Determiner - ClassC ' , ' ExpletivePronoun ' , ' IndefinitePronoun ' , ' Number - SP ' , ' ObjectPronoun ' , ' PossessivePronoun ' , ' PossessivePronoun - Post ' , ' Postdeterminer ' , ' Pronoun ' , ' Pronoun - SubjectOrObject ' , ' ReciprocalPronoun ' , ' ReflexivePronoun") #$BaseKB)
(f "Defx:PossessivePronounPossessivePronoun-Post-Pre")
(a '(#$comment #$Defx:PossessivePronounPossessivePronoun-Post-Pre "Determiner tag , staart , dt , jj , nnp , pdt , rb , ' Adverb - ClassB ' , ' Determiner - ClassC ' , ' ExpletivePronoun ' , ' IndefinitePronoun ' , ' Number - SP ' , ' ObjectPronoun ' , ' PossessivePronoun ' , ' PossessivePronoun - Post ' , ' Postdeterminer ' , ' Pronoun ' , ' Pronoun - SubjectOrObject ' , ' ReciprocalPronoun") #$BaseKB)
(f "Defx:Preposition-Directional-Telic")
(a '(#$comment #$Defx:Preposition-Directional-Telic "Determiner - ClassA ' , ' Determiner - ClassB ' , ' Determiner - ClassC ' , ' Determiner - Indefinite ' , ' Postdeterminer ' , ' WHDeterminer ' , ' CountNoun ' , ' MassNoun ' , ' MassNoun - Generic ' ]") #$BaseKB)
(f "Defx:Sit")
(a '(#$comment #$Defx:Sit "` wants ( J , Sit0 ) , Sit0 = and ( txtDenotes ( ` the tallest man '' , Sit2 ) , Sit2 = compareForExtent ( Man , Rest , tHumanMale , mudHeight , greaterThan ) , txtDenotes (") #$BaseKB)
(f "Defx:True-JustificationTruth")
(a '(#$comment #$Defx:True-JustificationTruth "# $ genls # $ Coffee - Beverage # $ Drink ) TRUE ( # $ genls # $ Drink # $ LiquidTangibleThing ) TRUE ( # $ genls # $ LiquidTangibleThing # $ FluidTangibleThing ) TRUE ( # $ disjointWith # $ FluidTangibleThing # $ Agent - PartiallyTangible ) TRUE") #$BaseKB)
(f "Defx:GoalChangesMadeAvailable")
(a '(#$comment #$Defx:GoalChangesMadeAvailable "Promote1 She1 , Announced1 , increaseCausually ( SafetyLevel1 ) ) , goalChanges ( Promote1 , increaseCausually ( SafetyLevel2 ) ) ) ) )") #$BaseKB)
(f "Defx:EnlightenedUpdate")
(a '(#$comment #$Defx:EnlightenedUpdate "computational architecture for presupposition and other pragmatic phenomena") #$BaseKB)
(f "Defx:Text-Adventures")
(a '(#$comment #$Defx:Text-Adventures "computer games that simulate a physical environment which can be manipulated by means of natural language requests") #$BaseKB)
(f "Defx:ActionDatabase")
(a '(#$comment #$Defx:ActionDatabase "includes the definitions of the actions that can be executed by the player ( such as take or open )") #$BaseKB)
(f "Defx:ClarificationRequest")
(a '(#$comment #$Defx:ClarificationRequest "has the effect of assigning to the player the responsability of finding the key before trying to open the chest") #$BaseKB)
(f "Defx:ContentDeterminationModule")
(a '(#$comment #$Defx:ContentDeterminationModule "constructs the semantic representation of the effects that were applied , updates the player KB with it and passes it to the next module for its verbalization ( so that the player knows what changed in the world )") #$BaseKB)
(f "Defx:ParsingModule")
(a '(#$comment #$Defx:ParsingModule "performs the syntactic analysis of a command issued by the player , and constructs its semantic representation using the TAG parser Tulipa") #$BaseKB)
(f "Defx:RealizationModule")
(a '(#$comment #$Defx:RealizationModule "works in the opposite direction , verbalizing the results of the execution of the command from the semantic representation using the TAG surface realizer GenI") #$BaseKB)
(f "Defx:ReferenceGeneration")
(a '(#$comment #$Defx:ReferenceGeneration "generates the semantic representation of a noun phrase that uniquely identifies an individual in the knowledge bases") #$BaseKB)
(f "Defx:-aryConditions")
(a '(#$comment #$Defx:-aryConditions "representation of x1 , , x : a ( x1 , , x ) b ( x1 , , x ) The extensions of conditions") #$BaseKB)
(f "Defx:Autonomous")
(a '(#$comment #$Defx:Autonomous "agents are capable of autonomous interaction with the environment") #$BaseKB)
(f "Defx:BreakTie")
(a '(#$comment #$Defx:BreakTie "tie - breaking function , where BreakTie ( { a1 , , an } ) = a means that a is the act to choose out of a set of permissible and equally preferred actions") #$BaseKB)
(f "Defx:ChoiceSet")
(a '(#$comment #$Defx:ChoiceSet "As choice - set of actions % from a set of feasible actions As for agent W % in situation Sit , according to the FnCS / N predicate % % PRECONDITION : % As is a subset of the set of feasible actions % for agent W in situation Sit % and Sit is a well - formed dnrDALMAS situation % and W is an agent in the agent set % , Sit , W , CS ) : state ( Sit , S ) , dDALMAS ( S , DDALMAS ) , choiceSetPredicate ( DDALMAS , Module : FnCS / N ) , functor ( FnCSGoal , FnCS , N ) , arg ( 1 , FnCSGoal , As ) , arg ( 2 , FnCSGoal , Sit ) , arg ( 3 , FnCSGoal , W ) , arg ( 4 , FnCSGoal , CS ) , call ( Module : FnCSGoal )") #$BaseKB)
(f "Defx:DALMAS")
(a '(#$comment #$Defx:DALMAS "all agents share the same knowledge of the environment by sharing the same knowledge base") #$BaseKB)
;; (f "Defx:DiscreteVs.ContinuousEnvironment")
;; (a '(#$comment #$Defx:DiscreteVs.ContinuousEnvironment "In a discrete environment there are a finite number of distinct and clearly defined percepts and actions") #$BaseKB)
(f "Defx:FeasibleActions")
(a '(#$comment #$Defx:FeasibleActions "set of acts and is a subset of consisting of the acts which are permissible for in situation < m , s >") #$BaseKB)
(f "Defx:Flexible")
(a '(#$comment #$Defx:Flexible "agents are intelligent and receptive to change in the environment") #$BaseKB)
(f "Defx:Protected")
(a '(#$comment #$Defx:Protected "protected sphere of in state s") #$BaseKB)
(f "Defx:Situated")
(a '(#$comment #$Defx:Situated "agents are situated in an environment and capable of perceiving information from the environment and acting upon it") #$BaseKB)
(f "Defx:Social")
(a '(#$comment #$Defx:Social "agents can communicate with and cooperate and/or negotiate with other agents") #$BaseKB)
;; (f "Defx:StaticVs.DynamicEnvironment")
;; (a '(#$comment #$Defx:StaticVs.DynamicEnvironment "If the environment only changes as a result of the actions performed by the agent , then it is static") #$BaseKB)
(f "Defx:WASTE-COLLECTORSSystem")
(a '(#$comment #$Defx:WASTE-COLLECTORSSystem "system of agents operating in an accessible , deterministic , static and discrete environment") #$BaseKB)
(f "Defx:ActionActionChangeChange")
(a '(#$comment #$Defx:ActionActionChangeChange "My My change Trying colourandform / n1 [ change ( form ) ] : atMove ( chroma ) AND diff [ ] [ chroma , forma ] -- > - My deontic structure [ chroma ] : [ change ( colour ) , change ( form ) ] - My preference structure [ chroma ] : [ p ( great , change ( colour ) ) , p ( medium , change ( form ) ( form ) , forma ) - My deontic structure [ forma ] : [ change ( colour ) ] - My preference structure [ forma ] : [ p ( medium , change ( colour ) ) ] - My choice set [ forma ] : [ change ( colour ) ] - I choose action change ( colour ) - My set of feasible actions [ chroma ] : [ change ( colour ) , change ( form ) ] - Trying colourandform / n1 [ change ( colour ) ] : atMove choice set [ chroma ] : [ change ( colour ) , change ( form ) set of feasible actions [ forma ] : [ change ( colour ) , change ( form ) ] - Trying colourandform / n1 [ change ( colour ) ] : atMove ( forma ) AND diff [ ] [ forma , chroma ] -- > - Trying colourandform / n1 [ change ( form ) ] : atMove ( forma ) AND diff [ ] [ forma , chroma ] -- > e ( 7 ) * eq [ ] [ forma , chroma ] -- > PROHIBITED ( change ( form ) , forma ) - My deontic structure [ forma ] : [ change ( colour ) ] - My preference structure [ forma ] : [ p ( medium , change ( colour ) ) ] - My choice set [ forma ] : [ change ( colour ) ] - I choose action change ( colour ) Sequence = [ dnrDALMAS_sit ( chroma , dnrDALMAS_state ( [ wState ( forma , forma , white , circle ) , wState ( chroma , chroma , black , square ) ] , dnrDALMAS ( dDALMAS ( [ forma , chroma ] , [ change ( colour ) , change ( form ) ] , user : agentResultOfAction/4 , dnrDALMAS : feasibleAction_default/3 , dnrDALMAS : permissibleAction_default/4 , user : agentUtilityFunction/4 , dnrDALMAS : choiceSet_default/4 , dnrDALMAS : turnOperator_default/2 , dnrDALMAS : tieBreaker_default/3 Prolog list consisting of the dnrDALMAS_sit/2 descriptor of the initial situation , a sequence of agent - action pairs showing the sequence of actions for this run , and a descriptor of the final situation") #$BaseKB)
(f "Defx:Agent")
(a '(#$comment #$Defx:Agent "computer system that is situated in some environment , and that is capable of autonomous action in this environment in order to meet its design objectives") #$BaseKB)
(f "Defx:AgentResultOfAction")
(a '(#$comment #$Defx:AgentResultOfAction "knowledgeBase ( S , KB ) , askKB ( aAt ( W , Pos ) , KB ) , adjacentLocation ( Pos , Dir , NextPos ) , Changes = [ del ( aPreviousAction ( W , _ ) ) , add ( aPreviousAction ( W , go ( Dir ) ) ) , del ( aAt ( W , Pos ) ) , add ( aAt ( W , NextPos ) ) ] , tellKB ( Changes , KB , NewKB") #$BaseKB)
(a '(#$comment #$Defx:AgentResultOfAction "S , KB ) , askKB ( aAt ( W , Pos ) , KB ) , not ( askKB ( aAt ( waste , Pos ) , KB ) ) , tellKB ( del ( aPreviousAction ( W , _ ) ) , KB , KB2 ) , tellKB ( add ( aPreviousAction ( W , grab ) ) , KB2 , NewKB ) , dnrDALMAS : knowledgeBaseUpdate ( S , NewKB , SPlus )") #$BaseKB)
(a '(#$comment #$Defx:AgentResultOfAction "del knowledgeBase ( S , KB ) , askKB ( aAt ( waste , Pos ) , KB ) , askKB ( aAt ( W , Pos ) , KB ) , askKB ( aHolding ( W , waste ( N ) ) , KB ( aPreviousAction ( W , _ ) ) , del ( aAt ( waste , Pos ) ) , del ( aHolding ( W , waste ( N ) ) ) , add ( aHolding ( W , waste ( N2 ) ) ) , add ( aPreviousAction ( W , grab )") #$BaseKB)
(f "Defx:AgentUtilityFunction")
(a '(#$comment #$Defx:AgentUtilityFunction "change ( form ) , Sit , W , Value") #$BaseKB)
(a '(#$comment #$Defx:AgentUtilityFunction "change ( form ) , Sit , W , medium") #$BaseKB)
(a '(#$comment #$Defx:AgentUtilityFunction "grab , Situation , W , Value ) : dnrDALMAS : state ( Situation , S ) , dnrDALMAS : knowledgeBase ( S , KB ) , askKB ( aAt ( W , Pos ) , KB ) , not ( askKB ( aAt ( waste , Pos ) , KB )") #$BaseKB)
(a '(#$comment #$Defx:AgentUtilityFunction "go") #$BaseKB)
(a '(#$comment #$Defx:AgentUtilityFunction "go") #$BaseKB)
(f "Defx:ConditionalNormativeSentence")
(a '(#$comment #$Defx:ConditionalNormativeSentence "consists of a combination of a descriptive sentence and a purely normative sentence") #$BaseKB)
(f "Defx:DeonticStructure")
(a '(#$comment #$Defx:DeonticStructure "deontic structure ) ordered in preference order % choiceSet_default ( FAs , Sit , W , CS ) : deonticStructure ( FAs , Sit , W , DS ) , preferenceStructure ( DS , Sit , W , PS ) , cs ( PS , CS )") #$BaseKB)
(f "Defx:DeterministicEnvironment")
(a '(#$comment #$Defx:DeterministicEnvironment "one where the next state of the environment is completely determined by the current state and the actions selected by the agent") #$BaseKB)
(f "Defx:DnrDALMASFramework")
(a '(#$comment #$Defx:DnrDALMASFramework "Prolog module consisting of implementations of the predicates described in section 6 , and a set of predicates designed to simplify the process of implementing a specific deterministic DALMAS") #$BaseKB)
(f "Defx:DnrDALMASModule")
(a '(#$comment #$Defx:DnrDALMASModule "contains a set of predicates for querying and updating dnrDALMAS situations , states and dnrDALMAS descriptors") #$BaseKB)
(f "Defx:East")
(a '(#$comment #$Defx:East "permissible M1Lap2 , T3Lap0 M1Lap2 , T4Lap0 M1Lap2 , T5Lap0 M1Lap2 , T6Lap0 M1Lap2 , T7Lap0 go ( south ) permissible , all other acts prohibited go ( south ) prohibited , all other acts permissible go ( south ) permissible go ( west ) permissible , all other acts prohibited go ( west ) prohibited , all other acts permissible go ( west ) permissible , all other acts prohibited go ( west ) prohibited , all other acts permissible go ( west ) prohibited ,") #$BaseKB)
(f "Defx:ElementaryNorm")
(a '(#$comment #$Defx:ElementaryNorm "norm x , y where the consequence y is an element of DT") #$BaseKB)
(f "Defx:EnvironmentEpisodic")
(a '(#$comment #$Defx:EnvironmentEpisodic "environment in which the agent s experience can be divided into episodes consisting of the agent perceiving and acting , and where the quality of action only depends on the current episode") #$BaseKB)
(f "Defx:Functions")
(a '(#$comment #$Defx:Functions "each function defines a transformation rule from one state in the state space to another") #$BaseKB)
(f "Defx:Goal-BasedAgents")
(a '(#$comment #$Defx:Goal-BasedAgents "have goals that describe a desirable state for the agent and mechanisms ( such as planning ) for choosing actions that lead to these goals") #$BaseKB)
(f "Defx:GroundConsequence")
(a '(#$comment #$Defx:GroundConsequence "relational statement equivalent to p , q R. A norm can then be represented as the ordered pair p , q , where p descriptive condition ) of the norm and q") #$BaseKB)
(f "Defx:GroundSatisfied")
(a '(#$comment #$Defx:GroundSatisfied "not ( G ) , GroundSet , WArgs , OtherArgs , Sit , WArgs2 ) : not ( groundSatisfied ( G , GroundSet , WArgs , OtherArgs , Sit , WArgs2 ) )") #$BaseKB)
(f "Defx:Model-BasedArchitecture")
(a '(#$comment #$Defx:Model-BasedArchitecture "agent constructs an internal model of the environment through the perceptions of the world and the knowledge about how the agent s actions affect its environment") #$BaseKB)
(f "Defx:Move")
(a '(#$comment #$Defx:Move "Module : C , CArgs , WArgs , OtherArgs , Sit , m ( N , Module : C , CArgs , WArgs , OtherArgs , Sit") #$BaseKB)
(f "Defx:Multi-AgentSystem")
(a '(#$comment #$Defx:Multi-AgentSystem "system of autonomous agents acting in relation to each other and to the environment") #$BaseKB)
(f "Defx:Non-ElementaryNorm")
(a '(#$comment #$Defx:Non-ElementaryNorm "norm x , y where the consequence y is an element of D*T , which means that it is a Boolean combination of elements of the form Tid") #$BaseKB)
(f "Defx:Norm")
(a '(#$comment #$Defx:Norm "element in a norm - set") #$BaseKB)
(f "Defx:Norm-RegulatedDALMAS")
(a '(#$comment #$Defx:Norm-RegulatedDALMAS "abstract architecture for a multi - agent system regulated by a normative system") #$BaseKB)
(a '(#$comment #$Defx:Norm-RegulatedDALMAS "system [ D , N ] where D is a DALMAS and N is a normative system for D.") #$BaseKB)
(f "Defx:Norm-System")
(a '(#$comment #$Defx:Norm-System "dnrDALMAS representation of a normative system") #$BaseKB)
(a '(#$comment #$Defx:Norm-System "3-tuple C , D , J where C is a ground - set , D is a consequence - set and J is a norm - set") #$BaseKB)
(a '(#$comment #$Defx:Norm-System "ordered set of norms ) % and ID / N is the name of a norm % and G is the ground ( sit - condition ) of the norm % and C is the consequence of the norm % norm ( NS , ID / N , G , C ) : normSet ( NS , J ) , member ( n ( ID / N , G , C ) , J )") #$BaseKB)
(f "Defx:Overlap")
(a '(#$comment #$Defx:Overlap "number of elements ( squares ) in the intersection of protected spheres P1 and P2 : Lap ( i , 1 , 2 ; s ) iff Protected ( 1 , P1 ; s ) Protected ( 2 , P2 ; s ) i is the number of elements in P1 P2") #$BaseKB)
(f "Defx:PartialRun")
(a '(#$comment #$Defx:PartialRun "K < N , NextK is K+1 , nextSituation ( Sit , NextSit , W , Action ) , partialRun ( NextSit , NextK , N , [ [ W , Action ] |PartialSequence ] , Sequence )") #$BaseKB)
(f "Defx:PreferenceStructure")
(a '(#$comment #$Defx:PreferenceStructure "ordering of the acts in FeasibleActs ( , s ) according to the utility of the acts for the agent") #$BaseKB)
(f "Defx:SimpleReflexAgent")
(a '(#$comment #$Defx:SimpleReflexAgent "perceives properties of its environment , and reacts to the perceptions , but does not have a memory that keeps track of earlier percepts or actions") #$BaseKB)
(f "Defx:State")
(a '(#$comment #$Defx:State "state of affairs holding for the DALMAS at a particular time") #$BaseKB)
(f "Defx:Turn-Operator")
(a '(#$comment #$Defx:Turn-Operator "lets the agent take turns to move : NextToMove ( x ) = x+1 if x < n , where n is the number of agents in ; and NextToMove ( n ) = 1") #$BaseKB)
(f "Defx:UtilityPredicate")
(a '(#$comment #$Defx:UtilityPredicate "assigns for c a lower value ( meaning higher utility ) to action ac , and a higher value ( meaning lower utility )") #$BaseKB)
(f "Defx:ActiveXControl")
(a '(#$comment #$Defx:ActiveXControl "provides quick access to the Cyc KB , via interaction with existing GUI elements") #$BaseKB)
(f "Defx:AutomaticLineInsulationTest")
(a '(#$comment #$Defx:AutomaticLineInsulationTest "software and the Common Control Processor hardware for the ISDN Line Unit for the 5ESS Digital Switch") #$BaseKB)
(f "Defx:BasicMeetingScheduling")
(a '(#$comment #$Defx:BasicMeetingScheduling "ability to identify events that would affect existing meetings and inform participants using available means , and show initial capability for system to recognize how collected data will affect its plans and the plans of others") #$BaseKB)
(f "Defx:ElectrospaceSystems")
(a '(#$comment #$Defx:ElectrospaceSystems "Designed and installed secure communication systems at various U.S. Air Force bases") #$BaseKB)
(f "Defx:InterimStatusReports")
(a '(#$comment #$Defx:InterimStatusReports "Provide DARPA / IPTO Quarterly Status Reports ( Jan , Apr , & Oct ) and an Annual Project Summary Report ( July ) as detailed in BAA requirements") #$BaseKB)
(f "Defx:OfficeHelper")
(a '(#$comment #$Defx:OfficeHelper "Performs most basic office tasks , allowing humans to do more ( higher productivity ) and focus on goals") #$BaseKB)
(f "Defx:OnlineTaskExecutionThrust")
(a '(#$comment #$Defx:OnlineTaskExecutionThrust "develops the ability of the system to utilize existing on - line services as - is") #$BaseKB)
;; (f "Defx:RelianceComm/Tec")
;; (a '(#$comment #$Defx:RelianceComm/Tec "Designed Line Interface Unit software for the DISC*S system") #$BaseKB)
(f "Defx:Self-AwareAssistantAdvancedCommunicationShellAdvancedCommunicationsShell")
(a '(#$comment #$Defx:Self-AwareAssistantAdvancedCommunicationShellAdvancedCommunicationsShell "contains several modules that allow the end user to communicate with the assistant in a manner as close as possible to the way they communicate in their environment") #$BaseKB)
(f "Defx:TestSoftwareDesignEngineer")
(a '(#$comment #$Defx:TestSoftwareDesignEngineer "Created new ways to store and retrieve data over the inter / intranet") #$BaseKB)
(f "Defx:WearableComputingThrust")
(a '(#$comment #$Defx:WearableComputingThrust "Provides a demonstration of an on - body / in - pocket version of LESA") #$BaseKB)
(f "Defx:AutonomicMonitor")
(a '(#$comment #$Defx:AutonomicMonitor "special process designed to provide the inference engine with internal status information") #$BaseKB)
(f "Defx:BotManager")
(a '(#$comment #$Defx:BotManager "allowing one secretary to handle more work , or to focus on higher value work") #$BaseKB)
(f "Defx:ExplicitSelf-Awareness")
(a '(#$comment #$Defx:ExplicitSelf-Awareness "given the broad base of pre - existing actor based knowledge coupled with an open - ended ability to augment the ontology") #$BaseKB)
(f "Defx:KnowledgeAblationExperiments")
(a '(#$comment #$Defx:KnowledgeAblationExperiments "where various parts of the developed knowledge base will be removed or changes , and the performance and capability of the system will be measured") #$BaseKB)
(f "Defx:SelectiveInclusion")
(a '(#$comment #$Defx:SelectiveInclusion "insertion and deletion / disconnection") #$BaseKB)
(f "Defx:Self-NarrativeFormOfSelf-Awareness")
(a '(#$comment #$Defx:Self-NarrativeFormOfSelf-Awareness "telling a constant story about oneself to oneself and asking critical questions") #$BaseKB)
(f "Defx:ToolAblationExperiments")
(a '(#$comment #$Defx:ToolAblationExperiments "tool that has difference capabilities or characteristics will be use in different conditions") #$BaseKB)
(f "Defx:CycKnowledgeBase")
(a '(#$comment #$Defx:CycKnowledgeBase "bundles assertions based on a shared set of assumptions on which the truth of the assertions depends , or a shared topic ( world geography , brain tumors , pro football ) , or a shared source :") #$BaseKB)
(f "Defx:PropositionalInformationThingCounterfactualContext")
(a '(#$comment #$Defx:PropositionalInformationThingCounterfactualContext "each instance of this collection contains at least one assertion which is not generally taken to be true in the real world collection of microtheories , each of which contains the content ( the information ) contained in some informationbearing thing , such as a picture , movie , audio tape , or book") #$BaseKB)
(f "Defx:TheoryMicrotheory")
(a '(#$comment #$Defx:TheoryMicrotheory "collection of microtheories which contain substantial rules and knowledge that is stated in vocabulary from a specific # $ VocabularyMicrotheory") #$BaseKB)
(f "Defx:VocabularyMicrotheory")
(a '(#$comment #$Defx:VocabularyMicrotheory "collection of all microtheories which contain primarily definitional information , such as definitions of vocabulary having to do with transportation or with computer software") #$BaseKB)
(f "Defx:CounterfactualContext")
(a '(#$comment #$Defx:CounterfactualContext "microtheory in which at least some of the assertions in it are not taken to be true") #$BaseKB)
(f "Defx:Microtheory")
(a '(#$comment #$Defx:Microtheory "set of assertions from that sea , an identification of a group of assertions that we pick out from the knowledge base") #$BaseKB)
(f "Defx:Actions")
(a '(#$comment #$Defx:Actions "all that can be done in the virtual world by players and other entities") #$BaseKB)
(f "Defx:Case-BasedPlanning")
(a '(#$comment #$Defx:Case-BasedPlanning "extract plans the expert seemed to follow in order to use them in future plays of a game") #$BaseKB)
(f "Defx:METrainer")
(a '(#$comment #$Defx:METrainer "off - line system that does not interact with games but with their game traces") #$BaseKB)
(f "Defx:MMPM")
(a '(#$comment #$Defx:MMPM "middleware that supports the connection of AI techniques with games") #$BaseKB)
(a '(#$comment #$Defx:MMPM "middleware that supports the connection between games and learning engines , promoting the development of machine learning tech- niques in games") #$BaseKB)
(f "Defx:MMPMPro-Vides")
(a '(#$comment #$Defx:MMPMPro-Vides "set of native sensors that can be combined to specify basic queries about the current world state") #$BaseKB)
(f "Defx:Maps")
(a '(#$comment #$Defx:Maps "board where the dynamic elements ( or entities ) reside") #$BaseKB)
(f "Defx:PlayME")
(a '(#$comment #$Defx:PlayME "consists on confronting the ME to play versus a human player or another ME , imitating the behaviours learned from the expert") #$BaseKB)
(f "Defx:Sensors")
(a '(#$comment #$Defx:Sensors "all the aspects that can be measured in the virtual world") #$BaseKB)
(f "Defx:Traces")
(a '(#$comment #$Defx:Traces "input data for the learning engine so it processes these traces and generates a data pack- age which contains the knowledge inferred") #$BaseKB)
(f "Defx:Trainer")
(a '(#$comment #$Defx:Trainer "one who learn from traces one who interprets and executes the previous learned behaviours") #$BaseKB)
(f "Defx:ValidConditions")
(a '(#$comment #$Defx:ValidConditions "capture the fact that some combinations of parameters in some actions are not acceptable ( e.g. coordinates have to be always inside of the playing area )") #$BaseKB)
(f "Defx:FailureSuccessValidConditionsConditionsConditions")
(a '(#$comment #$Defx:FailureSuccessValidConditionsConditionsConditions "conditions that if satisfied after the action was initiated we know that the action will never succeed") #$BaseKB)
(f "Defx:GameDomain")
(a '(#$comment #$Defx:GameDomain "only information it needs to know about the concrete game being played") #$BaseKB)
(f "Defx:Script")
(a '(#$comment #$Defx:Script "defines the state transformation done by the action") #$BaseKB)
(f "Defx:Tracer")
(a '(#$comment #$Defx:Tracer "set of Java classes that the game invoke periodically with the MMPM game state objects to be stored") #$BaseKB)
(f "Defx:Actions")
(a '(#$comment #$Defx:Actions "all that can be done in the virtual world by players and other entities") #$BaseKB)
(f "Defx:Case-BasedPlanning")
(a '(#$comment #$Defx:Case-BasedPlanning "extract plans the expert seemed to follow in order to use them in future plays of a game") #$BaseKB)
(f "Defx:METrainer")
(a '(#$comment #$Defx:METrainer "off - line system that does not interact with games but with their game traces") #$BaseKB)
(f "Defx:MMPM")
(a '(#$comment #$Defx:MMPM "middleware that supports the connection of AI techniques with games") #$BaseKB)
(a '(#$comment #$Defx:MMPM "middleware that supports the connection between games and learning engines , promoting the development of machine learning tech- niques in games") #$BaseKB)
(f "Defx:MMPMPro-Vides")
(a '(#$comment #$Defx:MMPMPro-Vides "set of native sensors that can be combined to specify basic queries about the current world state") #$BaseKB)
(f "Defx:Maps")
(a '(#$comment #$Defx:Maps "board where the dynamic elements ( or entities ) reside") #$BaseKB)
(f "Defx:PlayME")
(a '(#$comment #$Defx:PlayME "consists on confronting the ME to play versus a human player or another ME , imitating the behaviours learned from the expert") #$BaseKB)
(f "Defx:Sensors")
(a '(#$comment #$Defx:Sensors "all the aspects that can be measured in the virtual world") #$BaseKB)
(f "Defx:Traces")
(a '(#$comment #$Defx:Traces "input data for the learning engine so it processes these traces and generates a data pack- age which contains the knowledge inferred") #$BaseKB)
(f "Defx:Trainer")
(a '(#$comment #$Defx:Trainer "one who learn from traces one who interprets and executes the previous learned behaviours") #$BaseKB)
(f "Defx:ValidConditions")
(a '(#$comment #$Defx:ValidConditions "capture the fact that some combinations of parameters in some actions are not acceptable ( e.g. coordinates have to be always inside of the playing area )") #$BaseKB)
(f "Defx:FailureSuccessValidConditionsConditionsConditions")
(a '(#$comment #$Defx:FailureSuccessValidConditionsConditionsConditions "conditions that if satisfied after the action was initiated we know that the action will never succeed") #$BaseKB)
(f "Defx:GameDomain")
(a '(#$comment #$Defx:GameDomain "only information it needs to know about the concrete game being played") #$BaseKB)
(f "Defx:Script")
(a '(#$comment #$Defx:Script "defines the state transformation done by the action") #$BaseKB)
(f "Defx:Tracer")
(a '(#$comment #$Defx:Tracer "set of Java classes that the game invoke periodically with the MMPM game state objects to be stored") #$BaseKB)
(f "Defx:DefeasibleDeonticLogic")
(a '(#$comment #$Defx:DefeasibleDeonticLogic "family of logics that extend DL by adding deontic and other modal operators") #$BaseKB)
(f "Defx:DefeasibleMulti-ModalLogic")
(a '(#$comment #$Defx:DefeasibleMulti-ModalLogic "general multi - modal logical framework") #$BaseKB)
(f "Defx:DefeasibleRuleTheory")
(a '(#$comment #$Defx:DefeasibleRuleTheory "structure ( R , > ) , where R is a set of defeasible rules and defeaters , and >") #$BaseKB)
(f "Defx:DefeasibleTheory")
(a '(#$comment #$Defx:DefeasibleTheory "structure ( F , R , > ) where F is a set of literals , R is a set of defeasible rules and defaters , and the superiority relation > is such that > = > sm > Conflict") #$BaseKB)
(f "Defx:Dr-Prolog")
(a '(#$comment #$Defx:Dr-Prolog "system for defeasible reasoning with rules and ontologies on the semantic web") #$BaseKB)
(f "Defx:ConflictingRule")
(a '(#$comment #$Defx:ConflictingRule "one of the elements of the body of the rule is not provable with the appropriate modality") #$BaseKB)
(f "Defx:DefeasibleTheory")
(a '(#$comment #$Defx:DefeasibleTheory "consists of a set of facts or indisputable ( non modal ) statements , n sets of rules for the modalities") #$BaseKB)
;; (f "Defx:SetOfConflictRelationsSuperiorityRelation>AmongRules")
;; (a '(#$comment #$Defx:SetOfConflictRelationsSuperiorityRelation>AmongRules "single rule may override the conclusion of another rule") #$BaseKB)
(f "Defx:SuperiorityRelation")
(a '(#$comment #$Defx:SuperiorityRelation "provides information about the relative strength of rules , i.e. , about which rules can overrule which other rules") #$BaseKB)
(f "Defx:SemanticWeb")
(a '(#$comment #$Defx:SemanticWeb "extension of the current web where information is given well - defined meaning , better enabling computers and people to work in cooperation") #$BaseKB)
(f "Defx:ConceptualOntologies")
(a '(#$comment #$Defx:ConceptualOntologies "structured real - world information into computer - understandable data") #$BaseKB)
(f "Defx:ARPAARPAARPALTMLCS-RomeLabsPlanningInitiative-RomeLabsPlanningInitiative-RomeLabsPlanningInitiative")
(a '(#$comment #$Defx:ARPAARPAARPALTMLCS-RomeLabsPlanningInitiative-RomeLabsPlanningInitiative-RomeLabsPlanningInitiative "Reflective knowledge language Systems models automated processing of Arabic dispatches of the world ( including other entities and self ) , and use them productively to solve novel problems and deal successfully with unanticipated circumstances Acquiring models = learning Including : by observation , exploration and experiment , teaching and coaching , reading Using models = reasoning Including : mental simulation , hypotheticals , plausible inference , logical thinking Will yield robust , adaptable , transparent , supervisable , autonomous systems that know what they re doing A cognitive system is one that SWANS Conference , 4/7/2005 can reason , using substantial amounts of appropriately represented knowledge can learn from its experience so that it performs better tomorrow than it did today can explain itself and be told what to do can be aware of its own capabilities and reflect on its own behavior can respond robustly to surprise Approved for Public Release , gesture , image base Processes KR Perception STM Deliberative Processes N R A Communication ( language , gesture , image ) LE G N I KR LTM ( knowledge base") #$BaseKB)
